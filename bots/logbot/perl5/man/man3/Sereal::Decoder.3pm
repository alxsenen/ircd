.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Sereal::Decoder 3pm"
.TH Sereal::Decoder 3pm "2020-02-04" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sereal::Decoder \- Fast, compact, powerful binary deserialization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Sereal::Decoder
\&    qw(decode_sereal sereal_decode_with_object scalar_looks_like_sereal);
\&
\&  my $decoder = Sereal::Decoder\->new({...options...});
\&
\&  my $structure;
\&  $decoder\->decode($blob, $structure); # deserializes into $structure
\&
\&  # or if you don\*(Aqt have references to the top level structure, this works, too:
\&  $structure = $decoder\->decode($blob);
\&
\&  # alternatively functional interface: (See Sereal::Performance)
\&  sereal_decode_with_object($decoder, $blob, $structure);
\&  $structure = sereal_decode_with_object($decoder, $blob);
\&
\&  # much slower functional interface with no persistent objects:
\&  decode_sereal($blob, {... options ...}, $structure);
\&  $structure = decode_sereal($blob, {... options ...});
\&
\&  # Not a full validation, but just a quick check for a reasonable header:
\&  my $is_likely_sereal = scalar_looks_like_sereal($some_string);
\&  # or:
\&  $is_likely_sereal = $decoder\->looks_like_sereal($some_string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library implements a deserializer for an efficient, compact-output,
and feature-rich binary protocol called \fISereal\fR.
Its sister module Sereal::Encoder implements an encoder for this format.
The two are released separately to allow for independent and safer upgrading.
.PP
The Sereal protocol versions that are compatible with this decoder
implementation are currently protocol versions 1, 2, 3 and 4. As it stands, it
will refuse to attempt to decode future versions of the protocol, but if
necessary there is likely going to be an option to decode the parts of the
input that are compatible with version 4 of the protocol. The protocol was
designed to allow for this.
.PP
The protocol specification and many other bits of documentation
can be found in the github repository. Right now, the specification is at
<https://github.com/Sereal/Sereal/blob/master/sereal_spec.pod>,
there is a discussion of the design objectives in
<https://github.com/Sereal/Sereal/blob/master/README.pod>, and the output
of our benchmarks can be seen at
<https://github.com/Sereal/Sereal/wiki/Sereal\-Comparison\-Graphs>.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "new"
.IX Subsection "new"
Constructor. Optionally takes a hash reference as first parameter. This hash
reference may contain any number of options that influence the behaviour of the
encoder.
.PP
Currently, the following options are recognized, none of them are on
by default.
.PP
\fIrefuse_snappy\fR
.IX Subsection "refuse_snappy"
.PP
If set, the decoder will refuse Snappy-compressed input data. This can be
desirable for robustness. See the section \f(CW\*(C`ROBUSTNESS\*(C'\fR below.
.PP
\fIrefuse_objects\fR
.IX Subsection "refuse_objects"
.PP
If set, the decoder will refuse deserializing any objects in the input stream and
instead throw an exception. Defaults to off. See the section \f(CW\*(C`ROBUSTNESS\*(C'\fR below.
.PP
\fIno_bless_objects\fR
.IX Subsection "no_bless_objects"
.PP
If set, the decoder will deserialize any objects in the input stream but without
blessing them. Defaults to off. See the section \f(CW\*(C`ROBUSTNESS\*(C'\fR below.
.PP
\fIvalidate_utf8\fR
.IX Subsection "validate_utf8"
.PP
If set, the decoder will refuse invalid \s-1UTF\-8\s0 byte sequences. This is off
by default, but it's strongly encouraged to be turned on if you're dealing
with any data that has been encoded by an external source (e.g. http cookies).
.PP
\fImax_recursion_depth\fR
.IX Subsection "max_recursion_depth"
.PP
\&\f(CW\*(C`Sereal::Decoder\*(C'\fR is recursive. If you pass it a Sereal document that is deeply
nested, it will eventually exhaust the C stack. Therefore, there is a limit on
the depth of recursion that is accepted. It defaults to 10000 nested calls. You
may choose to override this value with the \f(CW\*(C`max_recursion_depth\*(C'\fR option.
Beware that setting it too high can cause hard crashes.
.PP
Do note that the setting is somewhat approximate. Setting it to 10000 may break at
somewhere between 9997 and 10003 nested structures depending on their types.
.PP
\fImax_num_hash_entries\fR
.IX Subsection "max_num_hash_entries"
.PP
If set to a non-zero value (default: 0), then \f(CW\*(C`Sereal::Decoder\*(C'\fR will refuse
to deserialize any hash/dictionary (or hash-based object) with more than
that number of entries. This is to be able to respond quickly to any future
hash-collision attacks on Perl's hash function. Chances are, you don't want
or need this. For a gentle introduction to the topic from the cryptographic
point of view, see <http://en.wikipedia.org/wiki/Collision_attack>.
.PP
\fIincremental\fR
.IX Subsection "incremental"
.PP
If set to a non-zero value (default: 0), then \f(CW\*(C`Sereal::Decoder\*(C'\fR will
destructively parse Sereal documents out of a variable. Every time a Sereal
document is successfully parsed it is removed from the front of the string
it is parsed from.
.PP
This means you can do this:
.PP
.Vb 3
\&    while (length $buffer) {
\&        my $data= decode_sereal($buffer,{incremental=>1});
\&    }
.Ve
.PP
\fIalias_smallint\fR
.IX Subsection "alias_smallint"
.PP
If set to a true value then \f(CW\*(C`Sereal::Decoder\*(C'\fR will share integers from
\&\-16 to 15 (encoded as either \s-1SRL_HDR_NEG\s0 and \s-1SRL_HDR_POS\s0) as read-only
aliases to a common \s-1SV.\s0
.PP
The result of this may be significant space savings in data structures with
many integers in the specified range. The cost is more memory used by the
decoder and a very modest speed penalty when deserializing.
.PP
Note this option changes the structure of the dumped data. Use with caution.
.PP
See also the \*(L"alias_varint_under\*(R" option.
.PP
\fIalias_varint_under\fR
.IX Subsection "alias_varint_under"
.PP
If set to a true positive integer smaller than 16 then this option is
similar to setting \*(L"alias_smallint\*(R" and causes all integers from \-16 to 15
to be shared as read-only aliases to the same \s-1SV,\s0 except that this treatment
\&\s-1ALSO\s0 applies to \s-1SRL_HDR_VARINT.\s0 If set to a value larger than 16 then this
applies to all varints varints under the value set. (In general \s-1SRL_HDR_VARINT\s0
is used only for integers larger than 15, and \s-1SRL_HDR_NEG\s0 and \s-1SRL_HDR_POS\s0 are
used for \-16 to \-1  and 0 to 15 respectively.)
.PP
In simple terms if you want to share values larger than 16 then you should use
this option, if you want to share only values in the \-16 to 15 range then you
should use the \*(L"alias_smallint\*(R" option instead.
.PP
The result of this may be significant space savings in data structures with
many integers in the desire range. The cost is more memory used by the decoder
and a very modest speed penalty when deserializing.
.PP
Note this option changes the structure of the dumped data. Use with caution.
.PP
\fIuse_undef\fR
.IX Subsection "use_undef"
.PP
If set to a true value then this any undef value to be deserialized as
PL_sv_undef. This may change the structure of the data structure being
dumped, do not enable this unless you know what you are doing.
.PP
\fIset_readonly\fR
.IX Subsection "set_readonly"
.PP
If set to a true value then the output will be completely readonly (deeply).
.PP
\fIset_readonly_scalars\fR
.IX Subsection "set_readonly_scalars"
.PP
If set to a true value then scalars in the output will be readonly (deeply).
References won't be readonly.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "decode"
.IX Subsection "decode"
Given a byte string of Sereal data, the \f(CW\*(C`decode\*(C'\fR call deserializes that data
structure. The result can be obtained in one of two ways: \f(CW\*(C`decode\*(C'\fR accepts
a second parameter, which is a scalar to write the result to, \s-1AND\s0 \f(CW\*(C`decode\*(C'\fR
will return the resulting data structure.
.PP
The two are subtly different in case of data structures that contain
references to the root element. In that case, the return value will be
a (non-recursive) copy of the reference. The pass-in style is more correct.
In other words,
.PP
.Vb 3
\&  $decoder\->decode($sereal_string, my $out);
\&  # is almost the same but safer than:
\&  my $out = $decoder\->decode($sereal_string);
.Ve
.PP
This is an unfortunate side-effect of perls standard copy semantics of
assignment. Possibly one day we will have an alternative to this.
.SS "decode_with_header"
.IX Subsection "decode_with_header"
Given a byte string of Sereal data, the \f(CW\*(C`decode_with_header\*(C'\fR call deserializes
that data structure as \f(CW\*(C`decode\*(C'\fR would do, however it also decodes the optional
user data structure that can be embedded into a Sereal document, inside the
header  (see Sereal::Encoder::encode).
.PP
It accepts an optional second parameter, which is a scalar to write the body
to, and an optional third parameter, which is a scalar to write the header to.
.PP
Regardless of the number of parameters received, \f(CW\*(C`decode_with_header\*(C'\fR returns
an ArrayRef containing the deserialized header, and the deserialized body, in
this order.
.PP
See \f(CW\*(C`decode\*(C'\fR for the subtle difference between the one, two and three
parameters versions.
.PP
If there is no header in a Sereal document, corresponding variable or return
value will be set to undef.
.SS "decode_only_header"
.IX Subsection "decode_only_header"
Given a byte string of Sereal data, the \f(CW\*(C`decode_only_header\*(C'\fR deserializes
only the optional user data structure that can be embedded into a Sereal
document, inside the header (see Sereal::Encoder::encode).
.PP
It accepts an optional second parameter, which is a scalar
to write the header to.
.PP
Regardless of the number of parameters received, \f(CW\*(C`decode_only_header\*(C'\fR returns
the resulting data structure.
.PP
See \f(CW\*(C`decode\*(C'\fR for the subtle difference between the one and two parameters
versions.
.PP
If there is no header in a Sereal document, corresponding variable or return
value will be set to undef.
.SS "decode_with_offset"
.IX Subsection "decode_with_offset"
Same as the \f(CW\*(C`decode\*(C'\fR method, except as second parameter, you must
pass an integer offset into the input string, at which the decoding is
to start. The optional \*(L"pass-in\*(R" style scalar (see \f(CW\*(C`decode\*(C'\fR above)
is relegated to being the third parameter.
.SS "decode_only_header_with_offset"
.IX Subsection "decode_only_header_with_offset"
Same as the \f(CW\*(C`decode_only_header\*(C'\fR method, except as second parameter, you must
pass an integer offset into the input string, at which the decoding is
to start. The optional \*(L"pass-in\*(R" style scalar (see \f(CW\*(C`decode_only_header\*(C'\fR above)
is relegated to being the third parameter.
.SS "decode_with_header_and_offset"
.IX Subsection "decode_with_header_and_offset"
Same as the \f(CW\*(C`decode_with_header\*(C'\fR method, except as second parameter, you must
pass an integer offset into the input string, at which the decoding is
to start. The optional \*(L"pass-in\*(R" style scalars (see \f(CW\*(C`decode_with_header\*(C'\fR above)
are relegated to being the third and fourth parameters.
.SS "bytes_consumed"
.IX Subsection "bytes_consumed"
After using the various \f(CW\*(C`decode\*(C'\fR methods documented previously,
\&\f(CW\*(C`bytes_consumed\*(C'\fR can return the number of bytes \fBfrom the body\fR of the input
string that were actually consumed by the decoder. That is, if you append
random garbage to a valid Sereal document, \f(CW\*(C`decode\*(C'\fR will happily decode the
data and ignore the garbage. If that is an error in your use case, you can use
\&\f(CW\*(C`bytes_consumed\*(C'\fR to catch it.
.PP
.Vb 4
\&  my $out = $decoder\->decode($sereal_string);
\&  if (length($sereal_string) != $decoder\->bytes_consumed) {
\&    die "Not all input data was consumed!";
\&  }
.Ve
.PP
Chances are that if you do this, you're violating \s-1UNIX\s0 philosophy
in \*(L"be strict in what you emit but lenient in what you accept\*(R".
.PP
You can also use this to deserialize a list of Sereal documents that
is concatenated into the same string (code not very robust...):
.PP
.Vb 10
\&  my @out;
\&  my $pos = 0;
\&  eval {
\&    while (1) {
\&      push @out, $decoder\->decode_with_offset($sereal_string, $pos);
\&      $pos += $decoder\->bytes_consumed;
\&      last if $pos >= length($sereal_string)
\&           or not $decoder\->bytes_consumed;
\&    }
\&  };
.Ve
.PP
As mentioned, only the bytes consumed from the body are considered. So the
following example is correct, as only the header is deserialized:
.PP
.Vb 3
\&  my $header = $decoder\->decode_only_header($sereal_string);
\&  my $count = $decoder\->bytes_consumed;
\&  # $count is 0
.Ve
.SS "decode_from_file"
.IX Subsection "decode_from_file"
.Vb 2
\&    Sereal::Decoder\->decode_from_file($file);
\&    $decoder\->decode_from_file($file);
.Ve
.PP
Read and decode the file specified. If called in list context
and incremental mode is enabled then decodes all packets
contained in the file and returns a list, otherwise decodes
the first (or only) packet in the file. Accepts an optinal
\&\*(L"target\*(R" variable as a second argument.
.SS "looks_like_sereal"
.IX Subsection "looks_like_sereal"
Performs some rudimentary check to determine if the argument
appears to be a valid Sereal packet or not. These tests are not
comprehensive and a true result does not mean that the document
is valid, merely that it appears to be valid. On the other hand
a false result is always reliable.
.PP
The return of this method may be treated as a simple boolean but
is in fact a more complex return. When the argument does not
look anything like a Sereal document then the return is perl's \s-1FALSE,\s0
which has the property of being string equivalent to "\*(L" and
numerically equivalent to 0. However when the argument appears to
be a \s-1UTF\-8\s0 encoded protocol 3 Sereal document (by noticing that
the \exF3 in the magic string has been replaced by \exC3\exB3) then
it returns 0 (the number, which is string equivalent to \*(R"0"), and
otherwise returns the protocol version of the document. This means
you can write something like this:
.PP
.Vb 8
\&    $type= Sereal::Decoder\->looks_like_sereal($thing);
\&    if ($type eq \*(Aq\*(Aq) {
\&        say "Not a Sereal document";
\&    } elsif ($type eq \*(Aq0\*(Aq) {
\&        say "Possibly utf8 encoded Sereal document";
\&    } else {
\&        say "Sereal document version $type";
\&    }
.Ve
.PP
For reference, Sereal's magic value is a four byte string which is
either \f(CW\*(C`=srl\*(C'\fR for protocol version 1 and 2 or \f(CW\*(C`=\exF3rl\*(C'\fR for protocol
version 3 and later. This function checks that the magic string
corresponds with the reported version number, as well as other
checks, which may be enhanced in the future.
.PP
Note that \fBlooks_like_sereal()\fR may be called as a class or object method,
and may also be called as a single argument function. See the related
\&\fBscalar_looks_like_sereal()\fR for a version which may \s-1ONLY\s0 be called as a
function, not as a method (and which is typically much faster).
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
.SS "sereal_decode_with_object"
.IX Subsection "sereal_decode_with_object"
The functional interface that is equivalent to using \f(CW\*(C`decode\*(C'\fR. Takes a
decoder object reference as first parameter, followed by a byte string
to deserialize.  Optionally takes a third parameter, which is the output
scalar to write to. See the documentation for \f(CW\*(C`decode\*(C'\fR above for details.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead. See
Sereal::Performance for a discussion on how to tune Sereal for maximum
performance if you need to.
.SS "sereal_decode_with_header_with_object"
.IX Subsection "sereal_decode_with_header_with_object"
The functional interface that is equivalent to using \f(CW\*(C`decode_with_header\*(C'\fR.
Takes a decoder object reference as first parameter, followed by a byte string
to deserialize. Optionally takes third and fourth parameters, which are
the output scalars to write to. See the documentation for \f(CW\*(C`decode_with_header\*(C'\fR
above for details.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead. See
Sereal::Performance for a discussion on how to tune Sereal for maximum
performance if you need to.
.SS "sereal_decode_only_header_with_object"
.IX Subsection "sereal_decode_only_header_with_object"
The functional interface that is equivalent to using \f(CW\*(C`decode_only_header\*(C'\fR.
Takes a decoder object reference as first parameter, followed by a byte string
to deserialize. Optionally takes a third parameters, which outputs scalars to write to.
See the documentation for \f(CW\*(C`decode_with_header\*(C'\fR above for details.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead. See
Sereal::Performance for a discussion on how to tune Sereal for maximum
performance if you need to.
.SS "sereal_decode_only_header_with_offset_with_object"
.IX Subsection "sereal_decode_only_header_with_offset_with_object"
The functional interface that is equivalent to using \f(CW\*(C`decode_only_header_with_offset\*(C'\fR.
Same as the \f(CW\*(C`sereal_decode_only_header_with_object\*(C'\fR function,
except as the third parameter, you must
pass an integer offset into the input string, at which the decoding is
to start. The optional \*(L"pass-in\*(R" style scalar (see \f(CW\*(C`sereal_decode_only_header_with_object\*(C'\fR above)
is relegated to being the fourth parameter.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead. See
Sereal::Performance for a discussion on how to tune Sereal for maximum
performance if you need to.
.SS "sereal_decode_with_header_and_offset_with_object"
.IX Subsection "sereal_decode_with_header_and_offset_with_object"
The functional interface that is equivalent to using \f(CW\*(C`decode_with_header_and_offset\*(C'\fR.
Same as the \f(CW\*(C`sereal_decode_with_header_with_object\*(C'\fR function, except as the third parameter, you must
pass an integer offset into the input string, at which the decoding is
to start. The optional \*(L"pass-in\*(R" style scalars (see \f(CW\*(C`sereal_decode_with_header_with_object\*(C'\fR above)
are relegated to being the fourth and fifth parameters.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead. See
Sereal::Performance for a discussion on how to tune Sereal for maximum
performance if you need to.
.SS "sereal_decode_with_offset_with_object"
.IX Subsection "sereal_decode_with_offset_with_object"
The functional interface that is equivalent to using \f(CW\*(C`decode_with_offset\*(C'\fR.
Same as the \f(CW\*(C`sereal_decode_with_object\*(C'\fR function, except as the third parameter, you must
pass an integer offset into the input string, at which the decoding is
to start. The optional \*(L"pass-in\*(R" style scalar (see \f(CW\*(C`sereal_decode_with_object\*(C'\fR above)
is relegated to being the third parameter.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead. See
Sereal::Performance for a discussion on how to tune Sereal for maximum
performance if you need to.
.SS "decode_sereal"
.IX Subsection "decode_sereal"
The functional interface that is equivalent to using \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`decode\*(C'\fR.
Expects a byte string to deserialize as first argument, optionally followed
by a hash reference of options (see documentation for \f(CW\*(C`new()\*(C'\fR). Finally,
\&\f(CW\*(C`decode_sereal\*(C'\fR supports a third parameter, which is the output scalar
to write to. See the documentation for \f(CW\*(C`decode\*(C'\fR above for details.
.PP
This functional interface is significantly slower than the \s-1OO\s0 interface since
it cannot reuse the decoder object.
.SS "decode_sereal_with_header_data"
.IX Subsection "decode_sereal_with_header_data"
The functional interface that is equivalent to using \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`decode_with_header\*(C'\fR.
Expects a byte string to deserialize as first argument, optionally followed
by a hash reference of options (see documentation for \f(CW\*(C`new()\*(C'\fR). Finally,
\&\f(CW\*(C`decode_sereal\*(C'\fR supports third and fourth parameters, which are the output scalars
to write to. See the documentation for \f(CW\*(C`decode_with_header\*(C'\fR above for details.
.PP
This functional interface is significantly slower than the \s-1OO\s0 interface since
it cannot reuse the decoder object.
.SS "scalar_looks_like_sereal"
.IX Subsection "scalar_looks_like_sereal"
The functional interface that is equivalent to using \f(CW\*(C`looks_like_sereal\*(C'\fR.
.PP
Note that this version cannot be called as a method. It is normally executed
as a custom opcode, as such errors about its usage may be caught at compile
time, and it should be much faster than looks_like_sereal.
.SH "ROBUSTNESS"
.IX Header "ROBUSTNESS"
This implementation of a Sereal decoder tries to be as robust to invalid
input data as reasonably possible. This means that it should never
(though read on) segfault. It may, however, cause a large malloc
to fail. Generally speaking, invalid data should cause a Perl-trappable
exception. The one exception is that for Snappy-compressed Sereal documents,
the Snappy library may cause segmentation faults (invalid reads or writes).
This should only be a problem if you do not checksum your data (internal
checksum support is a To-Do) or if you accept data from potentially
malicious sources.
.PP
It requires a lot of run-time boundary checks to prevent decoder
segmentation faults on invalid data. We implemented them in the
lightest way possible. Adding robustness against running out of memory
would cause an very significant run-time overhead. In most cases of
random garbage (with valid header no less) when a \fBmalloc()\fR fails due
to invalid data, the problem was caused by a very large array or
string length. This kind of very large malloc can then fail, being
trappable from Perl. Only when packet causes many repeated allocations
do you risk causing a hard \s-1OOM\s0 error from the kernel that cannot be
trapped because Perl may require some small allocations to succeed
before the now-invalid memory is released. It is at least not entirely
trivial to craft a Sereal document that causes this behaviour.
.PP
Finally, deserializing proper objects is potentially a problem because
classes can define a destructor. Thus, the data fed to the decoder can
cause the (deferred) execution of any destructor in your application.
That's why the \f(CW\*(C`refuse_objects\*(C'\fR option exists and what the \f(CW\*(C`no_bless_objects\*(C'\fR
can be used for as well. Later on, we may or may not provide a facility to
whitelist classes. Furthermore, if the encoder emitted any objects using
\&\f(CW\*(C`FREEZE\*(C'\fR callbacks, the \f(CW\*(C`THAW\*(C'\fR class method may be invoked on the
respective classes. If you can't trust the source of your Sereal documents,
you may want to use the \f(CW\*(C`refuse_objects\*(C'\fR option. For more details on
the \f(CW\*(C`FREEZE/THAW\*(C'\fR mechanism, please refer to Sereal::Encoder.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
Please refer to the Sereal::Performance document
that has more detailed information about Sereal performance and
tuning thereof.
.SH "THREAD-SAFETY"
.IX Header "THREAD-SAFETY"
\&\f(CW\*(C`Sereal::Decoder\*(C'\fR is thread-safe on Perl's 5.8.7 and higher. This means
\&\*(L"thread-safe\*(R" in the sense that if you create a new thread, all
\&\f(CW\*(C`Sereal::Decoder\*(C'\fR objects will become a reference to undef in the new
thread. This might change in a future release to become a full clone
of the decoder object.
.SH "BUGS, CONTACT AND SUPPORT"
.IX Header "BUGS, CONTACT AND SUPPORT"
For reporting bugs, please use the github bug tracker at
<http://github.com/Sereal/Sereal/issues>.
.PP
For support and discussion of Sereal, there are two Google Groups:
.PP
Announcements around Sereal (extremely low volume):
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-announce>
.PP
Sereal development list:
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-dev>
.SH "AUTHORS AND CONTRIBUTORS"
.IX Header "AUTHORS AND CONTRIBUTORS"
Yves Orton <demerphq@gmail.com>
.PP
Damian Gryski
.PP
Steffen Mueller <smueller@cpan.org>
.PP
Rafaël Garcia-Suarez
.PP
Ævar Arnfjörð Bjarmason <avar@cpan.org>
.PP
Tim Bunce
.PP
Daniel Dragan <bulkdd@cpan.org> (Windows support and bugfixes)
.PP
Zefram
.PP
Borislav Nikolov
.PP
Ivan Kruglov <ivan.kruglov@yahoo.com>
.PP
Eric Herman <eric@freesa.org>
.PP
Some inspiration and code was taken from Marc Lehmann's
excellent \s-1JSON::XS\s0 module due to obvious overlap in
problem domain.
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
This module was originally developed for Booking.com.
With approval from Booking.com, this module was generalized
and published on \s-1CPAN,\s0 for which the authors would like to express
their gratitude.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2012, 2013, 2014 by Steffen Mueller
Copyright (C) 2012, 2013, 2014 by Yves Orton
.PP
The license for the code in this distribution is the following,
with the exceptions listed below:
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Except portions taken from Marc Lehmann's code for the \s-1JSON::XS\s0
module, which is licensed under the same terms as this module.
(Many thanks to Marc for inspiration, and code.)
.PP
Also except the code for Snappy compression library, whose license
is reproduced below and which, to the best of our knowledge,
is compatible with this module's license. The license for the
enclosed Snappy code is:
.PP
.Vb 2
\&  Copyright 2011, Google Inc.
\&  All rights reserved.
\&
\&  Redistribution and use in source and binary forms, with or without
\&  modification, are permitted provided that the following conditions are
\&  met:
\&
\&    * Redistributions of source code must retain the above copyright
\&  notice, this list of conditions and the following disclaimer.
\&    * Redistributions in binary form must reproduce the above
\&  copyright notice, this list of conditions and the following disclaimer
\&  in the documentation and/or other materials provided with the
\&  distribution.
\&    * Neither the name of Google Inc. nor the names of its
\&  contributors may be used to endorse or promote products derived from
\&  this software without specific prior written permission.
\&
\&  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\&  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
\&  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
\&  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
\&  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
\&  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
\&  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
\&  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
\&  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
\&  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
\&  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve

.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::DNS::Native 3pm"
.TH Net::DNS::Native 3pm "2014-12-17" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::DNS::Native \- non\-blocking system DNS resolver
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&        use Net::DNS::Native;
\&        use IO::Select;
\&        use Socket;
\&        
\&        my $dns = Net::DNS::Native\->new();
\&        my $sock = $dns\->getaddrinfo("google.com");
\&        
\&        my $sel = IO::Select\->new($sock);
\&        $sel\->can_read(); # wait until resolving done
\&        my ($err, @res) = $dns\->get_result($sock);
\&        die "Resolving failed: ", $err if ($err);
\&        
\&        for my $r (@res) {
\&                warn "google.com has ip ",
\&                        $r\->{family} == AF_INET ?
\&                                inet_ntoa((unpack_sockaddr_in($r\->{addr}))[1]) :                   # IPv4
\&                                Socket::inet_ntop(AF_INET6, (unpack_sockaddr_in6($r\->{addr}))[1]); # IPv6
\&        }
.Ve
.Sp
.Vb 3
\&        use Net::DNS::Native;
\&        use AnyEvent;
\&        use Socket;
\&        
\&        my $dns = Net::DNS::Native\->new;
\&        
\&        my $cv = AnyEvent\->condvar;
\&        $cv\->begin;
\&        
\&        for my $host (\*(Aqgoogle.com\*(Aq, \*(Aqgoogle.ru\*(Aq, \*(Aqgoogle.cy\*(Aq) {
\&                my $fh = $dns\->inet_aton($host);
\&                $cv\->begin;
\&                
\&                my $w; $w = AnyEvent\->io(
\&                        fh   => $fh,
\&                        poll => \*(Aqr\*(Aq,
\&                        cb   => sub {
\&                                my $ip = $dns\->get_result($fh);
\&                                warn $host, $ip ? " has ip " . inet_ntoa($ip) : " has no ip";
\&                                $cv\->end;
\&                                undef $w;
\&                        }
\&                )
\&        }
\&        
\&        $cv\->end;
\&        $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides several methods for host name resolution. It is designed to be used with event loops. All resolving are done
by \fBgetaddrinfo\fR\|(3) implemented in your system library. Since \fBgetaddrinfo()\fR is blocking function and we don't want to block,
calls to this function will be done in separate thread. This class uses system native threads and not perl threads. So overhead
shouldn't be too big.
.SH "INSTALLATION WARNING"
.IX Header "INSTALLATION WARNING"
For some platforms to support threaded extensions like this one your perl should be linked with threads library. At the
installation time this module will check is your perl is good enough and will not install if not.
.PP
If it will fail to install use instructions listed below.
.PP
One of the possible solution to make your perl compatible with this module is to build perl with perl threads support
using \f(CW\*(C`\-Dusethreads\*(C'\fR for \f(CW\*(C`Configure\*(C'\fR script. Other solution is to use \f(CW\*(C`\-A prepend:libswanted="pthread "\*(C'\fR, which will
just link non-threaded perl with pthreads.
.PP
On Linux with perl not linked with pthreads this module may die with appropriate message at require time. This may happen
if you are called some functions from system library related to \s-1DNS\s0 operations before loading of \f(CW\*(C`Net::DNS::Native\*(C'\fR (or some module,
like \f(CW\*(C`IO::Socket::IP\*(C'\fR, that you are already loaded, called it internally). So, on such perl \f(CW\*(C`use IO::Socket::IP; use Net::DNS::Native\*(C'\fR may fail, but
\&\f(CW\*(C`use Net::DNS::Native; use IO::Socket::IP\*(C'\fR will success. The reason of such check inside \f(CW\*(C`Net::DNS::Native\*(C'\fR is that calls to this
functions (gethostbyname, getprotobyname, inet_aton, getaddrinfo, ...) will cause loading of non-thread safe versions of \s-1DNS\s0 related
stuff and \f(CW\*(C`Net::DNS::Native\*(C'\fR loaded after that will not be able to override this with thread safe versions. So, at one moment your
program will simply exit with segfault. This is why this check and rule are very important.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
This is a class constructor. Accepts this optional parameters:
.ie n .IP "pool => $size" 4
.el .IP "pool => \f(CW$size\fR" 4
.IX Item "pool => $size"
If \f(CW$size\fR>0 will create thread pool with size=$size which will make resolving job. Otherwise will use default behavior:
create and finish thread for each resolving request. If thread pool is not enough big to process all supplied requests, than this
requests will be queued until one of the threads will become free to process next request from the queue.
.ie n .IP "extra_thread => $bool" 4
.el .IP "extra_thread => \f(CW$bool\fR" 4
.IX Item "extra_thread => $bool"
If pool option specified and \f(CW$bool\fR has true value will create temporary extra thread for each request that can't be handled by the
pool (when all workers in the pool are busy) instead of pushing it to the queue. This temporary thread will be finished immediatly
after it will process request.
.ie n .IP "notify_on_begin => $bool" 4
.el .IP "notify_on_begin => \f(CW$bool\fR" 4
.IX Item "notify_on_begin => $bool"
Extra mechanizm to notify caller that resolving for some host started. This is usefull for those who uses thread pool without \f(CW\*(C`extra_thread\*(C'\fR
option. When pool becomes full new queries will be queued, so you can specify \f(CW$bool\fR with true value if you want to receive notifications
when resolving will be really started. To notify it will simply make \f(CW$handle\fR received by methods below readable. After that you will need to read
data from this handle to make it non readable again, so you can receive next notification, when host resolving will be done. There will be 1 byte
of data which you should read. \f(CW"1"\fR for notification about start of the resolving and \f(CW"2"\fR for notification about finish of the resolving.
.Sp
.Vb 10
\&        my $dns = Net::DNS::Native\->new(pool => 1, notify_on_begin => 1);
\&        my $handle = $dns\->inet_aton("google.com");
\&        my $sel = IO::Select\->new($handle);
\&        $sel\->can_read(); # wait "begin" notification
\&        sysread($handle, my $buf, 1); # $buf eq "1", $handle is not readable again
\&        $sel\->can_read(); # wait "finish" notification
\&        # resolving done
\&        # we can sysread($handle, $buf, 1); again and $buf will be eq "2"
\&        # but this is not necessarily
\&        my $ip = $dns\->get_result($handle);
.Ve
.ie n .SS "getaddrinfo($host, $service, $hints)"
.el .SS "getaddrinfo($host, \f(CW$service\fP, \f(CW$hints\fP)"
.IX Subsection "getaddrinfo($host, $service, $hints)"
This is the most powerfull method. May resolve host to both IPv4 and IPv6 addresses. For full documentation see \fBgetaddrinfo()\fR.
This method accepts same parameters but instead of result returns handle on which you need to wait for availability to read.
.ie n .SS "inet_pton($family, $host)"
.el .SS "inet_pton($family, \f(CW$host\fP)"
.IX Subsection "inet_pton($family, $host)"
This method will resolve \f(CW$host\fR accordingly to \f(CW$family\fR, which may be \s-1AF_INET\s0 to resolve to IPv4 or \s-1AF_INET6\s0 to resolve to IPv6. For full
documentation see \fBinet_pton()\fR. This method accepts same parameters but instead of result returns
handle on which you need to wait for availability to read.
.SS "inet_aton($host)"
.IX Subsection "inet_aton($host)"
This method may be used only for resolving to IPv4. For full documentation see \fBinet_aton()\fR. This method accepts same
parameters but instead of result returns handle on which you need to wait for availability to read.
.SS "gethostbyname($host)"
.IX Subsection "gethostbyname($host)"
This method may be used only for resolving to IPv4. For full documentation see \fBgethostbyname()\fR <http://perldoc.perl.org/5.14.0/functions/gethostbyname.html>.
This method accepts same parameters but instead of result returns handle on which you need to wait for availability to read.
.SS "get_result($handle)"
.IX Subsection "get_result($handle)"
After handle returned by methods above will became ready for read you should call this method with handle as argument. It will
return results appropriate to the method which returned this handle. For \f(CW\*(C`getaddrinfo\*(C'\fR this will be \f(CW\*(C`($err, @res)\*(C'\fR list. For
\&\f(CW\*(C`inet_pton\*(C'\fR and \f(CW\*(C`inet_aton\*(C'\fR \f(CW$packed_address\fR or \f(CW\*(C`undef\*(C'\fR. For \f(CW\*(C`gethostbyname()\*(C'\fR \f(CW$packed_address\fR or \f(CW\*(C`undef\*(C'\fR in scalar context and
\&\f(CW\*(C`($name,$aliases,$addrtype,$length,@addrs)\*(C'\fR in list context.
.PP
\&\fB\s-1NOTE:\s0\fR it is important to call \fBget_result()\fR on returned handle when it will become ready for read. Because this method destroys resources
associated with this handle. Otherwise you will get memory leaks.
.SS "timedout($handle)"
.IX Subsection "timedout($handle)"
Mark resolving operation associated with this handle as timed out. This will not interrupt resolving operation (because there is no way to interrupt \fBgetaddrinfo\fR\|(3) correctly),
but will automatically discard any results returned when resolving will be done. So, after \f(CW\*(C`timedout($handle)\*(C'\fR you can forget about \f(CW$handle\fR and
associated resolving operation. And don't need to call \f(CW\*(C`get_result($handle)\*(C'\fR to destroy resources associated with this handle. Furthermore, if you are using thread pool
and all threads in pool are busy and \f(CW\*(C`extra_thread\*(C'\fR option not specified, but 1 resolving operation from this pool marked as timed out and you'll add one more resolving operation,
this operation will not be queued. Instead of this 1 temporary extra thread will be created to process this operation. So you can think about \f(CW\*(C`timedout\*(C'\fR like about real interrupter of
long running resolving operation. But you are warned how it really works.
.SH "AUTHOR"
.IX Header "AUTHOR"
Oleg G, <oleg@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself

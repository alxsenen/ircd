.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math::Int64 3pm"
.TH Math::Int64 3pm "2016-01-04" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Int64 \- Manipulate 64 bits integers in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::Int64 qw(int64 uint64);
\&
\&  my $i = int64(1);
\&  my $j = $i << 40;
\&  print($i + $j * 1000000);
\&
\&  my $k = uint64("12345678901234567890");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module adds support for 64 bit integers, signed and unsigned, to
Perl.
.SS "Exportable functions"
.IX Subsection "Exportable functions"
.IP "\fBint64()\fR" 4
.IX Item "int64()"
.PD 0
.IP "int64($value)" 4
.IX Item "int64($value)"
.PD
Creates a new int64 value and initializes it to \f(CW$value\fR, where
\&\f(CW$value\fR can be a Perl number or a string containing a number.
.Sp
For instance:
.Sp
.Vb 2
\&  $i = int64(34);
\&  $j = int64("\-123454321234543212345");
\&
\&  $k = int64(1234567698478483938988988); # wrong!!!
\&                                         #  the unquoted number would
\&                                         #  be converted first to a
\&                                         #  real number causing it to
\&                                         #  loose some precision.
.Ve
.Sp
Once the int64 number is created it can be manipulated as any other
Perl value supporting all the standard operations (addition, negation,
multiplication, postincrement, etc.).
.IP "net_to_int64($str)" 4
.IX Item "net_to_int64($str)"
Converts an 8 bytes string containing an int64 in network order to the
internal representation used by this module.
.IP "int64_to_net($int64)" 4
.IX Item "int64_to_net($int64)"
Returns an 8 bytes string with the representation of the int64 value
in network order.
.IP "native_to_int64($str)" 4
.IX Item "native_to_int64($str)"
.PD 0
.IP "int64_to_native($int64)" 4
.IX Item "int64_to_native($int64)"
.PD
similar to net_to_int64 and int64_to_net, but using the native \s-1CPU\s0
order.
.IP "int64_to_number($int64)" 4
.IX Item "int64_to_number($int64)"
returns the optimum representation of the int64 value using Perl
internal types (\s-1IV, UV\s0 or \s-1NV\s0). Precision may be lost.
.Sp
For instance:
.Sp
.Vb 5
\&  for my $l (10, 20, 30, 40, 50, 60) {
\&    my $i = int64(1) << $l;
\&    my $n = int64_to_number($i);
\&    print "int64:$i => perl:$n\en";
\&  }
.Ve
.ie n .IP "string_to_int64($str, $base)" 4
.el .IP "string_to_int64($str, \f(CW$base\fR)" 4
.IX Item "string_to_int64($str, $base)"
Converts the string to a int64 value. The conversion is done according
to the given base, which must be a number between 2 and 36 inclusive
or the special value 0. \f(CW$base\fR defaults to 0.
.Sp
The string may begin with an arbitrary amount of white space followed
by a single optional \f(CW\*(C`+\*(C'\fR or \f(CW\*(C`\-\*(C'\fR sign. If base is zero or 16, the
string may then include a \*(L"0x\*(R" prefix, and the number will be read in
base 16; otherwise, a zero base is taken as 10 (decimal) unless the
next character is '0', in which case it is taken as 8 (octal).
.Sp
Underscore characters (\f(CW\*(C`_\*(C'\fR) between the digits are ignored.
.Sp
No overflow checks are performed by this function unless the
\&\f(CW\*(C`die_on_overflow\*(C'\fR pragma is used (see \*(L"Die on overflow\*(R" below).
.Sp
See also \fBstrtoll\fR\|(3).
.IP "hex_to_int64($i64)" 4
.IX Item "hex_to_int64($i64)"
Shortcut for string_to_int64($str, 16)
.ie n .IP "int64_to_string($i64, $base)" 4
.el .IP "int64_to_string($i64, \f(CW$base\fR)" 4
.IX Item "int64_to_string($i64, $base)"
Converts the int64 value to its string representation in the given
base (defaults to 10).
.IP "int64_to_hex($i64)" 4
.IX Item "int64_to_hex($i64)"
Shortcut for \f(CW\*(C`int64_to_string($i64, 16)\*(C'\fR.
.IP "int64_to_BER($i64)" 4
.IX Item "int64_to_BER($i64)"
Converts the int64 value to its \s-1BER\s0 representation (see
\&\*(L"pack\*(R" in perlfunc for a description of the \s-1BER\s0 format).
.Sp
In the case of signed numbers, they are transformed into unsigned
numbers before encoding them in the \s-1BER\s0 format with the following
rule:
.Sp
.Vb 2
\&  $neg = ($i64 < 0 ? 1 : 0);
\&  $u64 = (($neg ? ~$i64 : $i64) << 1) | $neg;
.Ve
.Sp
That way, positive and negative integers are interleaved as 0, \-1, 1,
2, \-2, .... The format is similar to that used by Google protocol
buffers to encode signed variants but with the most significant groups
first (protocol buffers uses the least significant groups first
variant).
.Sp
If you don't want that preprocessing for signed numbers, just use the
\&\f(CW\*(C`uint64_to_BER\*(C'\fR function instead.
.IP "BER_to_int64($str)" 4
.IX Item "BER_to_int64($str)"
Decodes the int64 number in \s-1BER\s0 format from the given string.
.Sp
There must not be any extra bytes on the string after the encoded number.
.IP "BER_length($str)" 4
.IX Item "BER_length($str)"
Given a string with a \s-1BER\s0 encoded number at the beginning, this
function returns the number of bytes it uses.
.Sp
The right way to shift a \s-1BER\s0 encoded number from the beginning of some
string is as follows:
.Sp
.Vb 1
\&   $i64 = BER_to_int64(substr($str, 0, BER_length($str), \*(Aq\*(Aq));
.Ve
.IP "int64_rand" 4
.IX Item "int64_rand"
Generates a 64 bit random number using \s-1ISAAC\-64\s0 algorithm.
.IP "int64_srand($seed)" 4
.IX Item "int64_srand($seed)"
.PD 0
.IP "\fBint64_srand()\fR" 4
.IX Item "int64_srand()"
.PD
Sets the seed for the random number generator.
.Sp
\&\f(CW$seed\fR, if given, should be a 2KB long string.
.IP "uint64" 4
.IX Item "uint64"
.PD 0
.IP "uint64_to_number" 4
.IX Item "uint64_to_number"
.IP "net_to_uint64" 4
.IX Item "net_to_uint64"
.IP "uint64_to_net" 4
.IX Item "uint64_to_net"
.IP "native_to_uint64" 4
.IX Item "native_to_uint64"
.IP "uint64_to_native" 4
.IX Item "uint64_to_native"
.IP "string_to_uint64" 4
.IX Item "string_to_uint64"
.IP "hex_to_uint64" 4
.IX Item "hex_to_uint64"
.IP "uint64_to_string" 4
.IX Item "uint64_to_string"
.IP "uint64_to_hex" 4
.IX Item "uint64_to_hex"
.PD
These functions are similar to their int64 counterparts, but
manipulate 64 bit unsigned integers.
.IP "uint64_to_BER($u64)" 4
.IX Item "uint64_to_BER($u64)"
Encodes the given unsigned integer in \s-1BER\s0 format (see \*(L"pack\*(R" in perlfunc).
.IP "BER_to_uint64($str)" 4
.IX Item "BER_to_uint64($str)"
Decodes from the given string an unsigned number in \s-1BER\s0 format.
.IP "uint64_rand" 4
.IX Item "uint64_rand"
Generates a 64 bit random unsigned number using \s-1ISAAC\-64\s0 algorithm.
.SS "Die on overflow"
.IX Subsection "Die on overflow"
The lexical pragma \f(CW\*(C`Math::Int64::die_on_overflow\*(C'\fR configures the
module to throw an error when some operation results in integer
overflow.
.PP
For instance:
.PP
.Vb 2
\&  use Math::Int64 qw(uint64);
\&  use Math::Int64::die_on_overflow;
\&
\&  my $zero = uint64(0);
\&  say ($zero \- 1);                 # dies as \-1 falls outside
\&                                   # the uint64_t range
\&
\&  no Math::Int64::die_on_overflow; # deactivates lexical pragma
\&  say ($zero \- 1);                 # no error is detected here!
.Ve
.PP
The pragma can also be activated as follows:
.PP
.Vb 1
\&  use Math::Int64 \*(Aq:die_on_overflow\*(Aq;
.Ve
.PP
Once this pragma is used, several Math::Int64 operations may become
slower. Deactivating the pragma will not make them fast again.
.PP
On Perl 5.8.x, as lexical pragmas support is not available, the pragma
\&\f(CW\*(C`die_on_overflow\*(C'\fR pragma is global and can not be deactivated.
.SS "Fallback to native 64bit support if available"
.IX Subsection "Fallback to native 64bit support if available"
If the lexical pragma \f(CW\*(C`Math::Int64::native_if_available\*(C'\fR is used in
your program and the version of perl in use has native support for
64bit integers, the functions imported from the module that create
64bit integers (i.e. \f(CW\*(C`uint64\*(C'\fR, \f(CW\*(C`int64\*(C'\fR, \f(CW\*(C`string_to_int64\*(C'\fR,
\&\f(CW\*(C`native_to_int64\*(C'\fR, etc.) will return regular perl scalars.
.PP
For instance:
.PP
.Vb 1
\&  use Math::Int64 qw(int64);
\&
\&  $a = int64(34); # always returns an object of the class Math::Int64
\&
\&  use Math::Int64::native_if_available;
\&  $a = int64(34); # returns a regular scalar on perls compiled with
\&                  # 64bit support
.Ve
.PP
This feature is not enabled by default because the semantics for perl
scalars and for 64 bit integers as implemented in this module are not
identical.
.PP
Perl is prone to coerce integers into floats while this module keeps
then always as 64bit integers. Specifically, the division operation
and overflows are the most problematic cases. Also, when using native
integers, the signed/unsigned division blurs.
.PP
Besides that, in most situations it is safe to use the native fallback.
.PP
As happens with the \f(CW\*(C`die_on_overflow\*(C'\fR pragma, on Perl 5.8.x it is
global.
.PP
The pragma can also be activated as follows:
.PP
.Vb 1
\&  use Math::Int64 \*(Aq:native_if_available\*(Aq;
.Ve
.SS "Transparent conversion of objects to int64/uint64"
.IX Subsection "Transparent conversion of objects to int64/uint64"
When in some operation involving int64/uint64 numbers, a blessed
object is passed as an operand, the module would try to coerce the
object into an int64/uint64 number calling the methods
\&\f(CW\*(C`as_int64\*(C'\fR/\f(CW\*(C`as_uint64\*(C'\fR respectively.
.PP
If the corresponding method is not implemented, the object will be
stringified and then parsed as a base 10 number.
.SS "Storable integration"
.IX Subsection "Storable integration"
Objects of classes Math::Int64 and Math::UInt64 implement the
STORABLE_freeze and STORABLE_thaw methods for a transparent
integration with Storable.
.SS "C \s-1API\s0"
.IX Subsection "C API"
This module provides a native C \s-1API\s0 that can be used to create and
read Math::Int64 int64 and uint64 SVs from your own \s-1XS\s0 modules.
.PP
In order to use it you need to follow these steps:
.IP "\(bu" 4
Import the files \f(CW\*(C`perl_math_int64.c\*(C'\fR, \f(CW\*(C`perl_math_int64.h\*(C'\fR and
optionally \f(CW\*(C`typemaps\*(C'\fR from Math::Int64 \f(CW\*(C`c_api_client\*(C'\fR directory into
your project directory.
.IP "\(bu" 4
Include the file \f(CW\*(C`perl_math_int64.h\*(C'\fR in the C or \s-1XS\s0 source files
where you want to convert 64bit integers to/from Perl SVs.
.Sp
Note that this header file requires the types int64_t and uint64_t to
be defined beforehand.
.IP "\(bu" 4
Add the file \f(CW\*(C`perl_math_int64.c\*(C'\fR to your compilation targets (see the
sample Makefile.PL below).
.IP "\(bu" 4
Add a call to the macro \f(CW\*(C`PERL_MATH_INT64_LOAD_OR_CROAK\*(C'\fR into the
\&\f(CW\*(C`BOOT\*(C'\fR section of your \s-1XS\s0 file.
.PP
For instance:
.PP
.Vb 1
\& \-\-\- Foo64.xs \-\-\-\-\-\-\-\-\-
\&
\&  #include "EXTERN.h"
\&  #include "perl.h"
\&  #include "XSUB.h"
\&  #include "ppport.h"
\&
\&  /* #define MATH_INT64_NATIVE_IF_AVAILABLE */
\&  #include "math_int64.h"
\&
\&  MODULE = Foo64                PACKAGE = Foo64
\&  BOOT:
\&      PERL_MATH_INT64_LOAD_OR_CROAK;
\&
\&  int64_t
\&  some_int64()
\&  CODE:
\&      RETVAL = \-42;
\&  OUTPUT:
\&      RETVAL
\&
\&
\&  \-\-\- Makefile.PL \-\-\-\-\-
\&
\&  use ExtUtils::MakeMaker;
\&  WriteMakefile( NAME         => \*(AqFoo64\*(Aq,
\&                 VERSION_FROM => \*(Aqlib/Foo64.pm\*(Aq,
\&                 OBJECT       => \*(Aq$(O_FILES)\*(Aq );
.Ve
.PP
If the macro \f(CW\*(C`MATH_INT64_NATIVE_IF_AVAILABLE\*(C'\fR is defined before
including \f(CW\*(C`perl_math_int64.h\*(C'\fR and the perl interpreter is compiled
with native 64bit integer support, IVs will be used to represent 64bit
integers instead of the object representation provided by Math::Int64.
.PP
These are the C macros available from Math::Int64 C \s-1API:\s0
.IP "\s-1SV\s0 *newSVi64(int64_t i64)" 4
.IX Item "SV *newSVi64(int64_t i64)"
Returns an \s-1SV\s0 representing the given int64_t value.
.IP "\s-1SV\s0 *newSVu64(uint64_t 64)" 4
.IX Item "SV *newSVu64(uint64_t 64)"
Returns an \s-1SV\s0 representing the given uint64_t value.
.IP "int64_t SvI64(\s-1SV\s0 *sv)" 4
.IX Item "int64_t SvI64(SV *sv)"
Extracts the int64_t value from the given \s-1SV.\s0
.IP "uint64_t SvU64(\s-1SV\s0 *sv)" 4
.IX Item "uint64_t SvU64(SV *sv)"
Extracts the uint64_t value from the given \s-1SV.\s0
.IP "int SvI64OK(\s-1SV\s0 *sv)" 4
.IX Item "int SvI64OK(SV *sv)"
Returns true is the given \s-1SV\s0 contains a valid int64_t value.
.IP "int SvU64OK(\s-1SV\s0 *sv)" 4
.IX Item "int SvU64OK(SV *sv)"
Returns true is the given \s-1SV\s0 contains a valid uint64_t value.
.IP "uint64_t randU64(void)" 4
.IX Item "uint64_t randU64(void)"
Returns a random 64 bits unsigned integer.
.IP "\s-1SV\s0 sv_seti64(\s-1SV\s0 *sv, uint64_t i64)" 4
.IX Item "SV sv_seti64(SV *sv, uint64_t i64)"
Sets the value of the perl scalar to the given int64_t value.
.IP "\s-1SV\s0 sv_setu64(\s-1SV\s0 *sv, uint64_t i64)" 4
.IX Item "SV sv_setu64(SV *sv, uint64_t i64)"
Sets the value of the perl scalar to the given uint64_t value.
.PP
If you require any other function available through the C \s-1API\s0 don't
hesitate to ask for it!
.SH "BUGS AND SUPPORT"
.IX Header "BUGS AND SUPPORT"
The Storable integration feature is experimental.
.PP
The C \s-1API\s0 feature is experimental.
.PP
This module requires int64 support from the C compiler.
.PP
In order to report bugs you can send me and email to the address that
appears below or use the \s-1CPAN RT\s0 bug tracking system available at
<http://rt.cpan.org>.
.PP
The source for the development version of the module is hosted at
GitHub: <https://github.com/salva/p5\-Math\-Int64>.
.SS "My wishlist"
.IX Subsection "My wishlist"
If you like this module and you're feeling generous, take a look at my
Amazon Wish List: <http://amzn.com/w/1WU1P6IR5QZ42>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The C \s-1API\s0 usage sample module Math::Int64::C_API::Sample.
.PP
Other modules providing support for larger integers or numbers are
Math::BigInt, Math::BigRat and Math::Big,
Math::BigInt::BitVect, Math::BigInt::Pari and
Math::BigInt::GMP.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright © 2007, 2009, 2011\-2015 by Salvador Fandiño
(sfandino@yahoo.com)
.PP
Copyright © 2014\-2015 by Dave Rolsky (autarch@urth.org)
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.8 or,
at your option, any later version of Perl 5 you may have available.

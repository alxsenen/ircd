.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "EV 3pm"
.TH EV 3pm "2015-12-20" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
EV \- perl interface to libev, a high performance full\-featured event loop
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use EV;
\&   
\&   # TIMERS
\&   
\&   my $w = EV::timer 2, 0, sub {
\&      warn "is called after 2s";
\&   };
\&   
\&   my $w = EV::timer 2, 2, sub {
\&      warn "is called roughly every 2s (repeat = 2)";
\&   };
\&   
\&   undef $w; # destroy event watcher again
\&   
\&   my $w = EV::periodic 0, 60, 0, sub {
\&      warn "is called every minute, on the minute, exactly";
\&   };
\&   
\&   # IO
\&   
\&   my $w = EV::io *STDIN, EV::READ, sub {
\&      my ($w, $revents) = @_; # all callbacks receive the watcher and event mask
\&      warn "stdin is readable, you entered: ", <STDIN>;
\&   };
\&   
\&   # SIGNALS
\&   
\&   my $w = EV::signal \*(AqQUIT\*(Aq, sub {
\&      warn "sigquit received\en";
\&   };
\&   
\&   # CHILD/PID STATUS CHANGES
\&  
\&   my $w = EV::child 666, 0, sub {
\&      my ($w, $revents) = @_;
\&      my $status = $w\->rstatus;
\&   };
\&  
\&   # STAT CHANGES
\&   my $w = EV::stat "/etc/passwd", 10, sub {
\&      my ($w, $revents) = @_;
\&      warn $w\->path, " has changed somehow.\en";
\&   };
\&   
\&   # MAINLOOP
\&   EV::run;                # loop until EV::break is called or all watchers stop
\&   EV::run EV::RUN_ONCE;   # block until at least one event could be handled
\&   EV::run EV::RUN_NOWAIT; # try to handle same events, but do not block
.Ve
.SH "BEFORE YOU START USING THIS MODULE"
.IX Header "BEFORE YOU START USING THIS MODULE"
If you only need timer, I/O, signal, child and idle watchers and not the
advanced functionality of this module, consider using AnyEvent instead,
specifically the simplified \s-1API\s0 described in \s-1AE\s0.
.PP
When used with \s-1EV\s0 as backend, the \s-1AE\s0 \s-1API\s0 is as fast as the native \s-1EV\s0
\&\s-1API,\s0 but your programs/modules will still run with many other event loops.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface to libev
(<http://software.schmorp.de/pkg/libev.html>). While the documentation
below is comprehensive, one might also consult the documentation of
libev itself (<http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod> or
\&\fIperldoc EV::libev\fR) for more subtle details on watcher semantics or some
discussion on the available backends, or how to force a specific backend
with \f(CW\*(C`LIBEV_FLAGS\*(C'\fR, or just about in any case because it has much more
detailed information.
.PP
This module is very fast and scalable. It is actually so fast that you
can use it through the AnyEvent module, stay portable to other event
loops (if you don't rely on any watcher types not available through it)
and still be faster than with any other event loop currently supported in
Perl.
.SS "\s-1PORTING FROM EV 3.X\s0 to 4.X"
.IX Subsection "PORTING FROM EV 3.X to 4.X"
\&\s-1EV\s0 version 4 introduces a number of incompatible changes summarised
here. According to the depreciation strategy used by libev, there is a
compatibility layer in place so programs should continue to run unchanged
(the \s-1XS\s0 interface lacks this layer, so programs using that one need to be
updated).
.PP
This compatibility layer will be switched off in some future release.
.PP
All changes relevant to Perl are renames of symbols, functions and
methods:
.PP
.Vb 3
\&  EV::loop          => EV::run
\&  EV::LOOP_NONBLOCK => EV::RUN_NOWAIT
\&  EV::LOOP_ONESHOT  => EV::RUN_ONCE
\&
\&  EV::unloop        => EV::break
\&  EV::UNLOOP_CANCEL => EV::BREAK_CANCEL
\&  EV::UNLOOP_ONE    => EV::BREAK_ONE
\&  EV::UNLOOP_ALL    => EV::BREAK_ALL
\&
\&  EV::TIMEOUT       => EV::TIMER
\&
\&  EV::loop_count    => EV::iteration
\&  EV::loop_depth    => EV::depth
\&  EV::loop_verify   => EV::verify
.Ve
.PP
The loop object methods corresponding to the functions above have been
similarly renamed.
.SS "\s-1MODULE EXPORTS\s0"
.IX Subsection "MODULE EXPORTS"
This module does not export any symbols.
.SH "EVENT LOOPS"
.IX Header "EVENT LOOPS"
\&\s-1EV\s0 supports multiple event loops: There is a single \*(L"default event loop\*(R"
that can handle everything including signals and child watchers, and any
number of \*(L"dynamic event loops\*(R" that can use different backends (with
various limitations), but no child and signal watchers.
.PP
You do not have to do anything to create the default event loop: When
the module is loaded a suitable backend is selected on the premise of
selecting a working backend (which for example rules out kqueue on most
BSDs). Modules should, unless they have \*(L"special needs\*(R" always use the
default loop as this is fastest (perl-wise), best supported by other
modules (e.g. AnyEvent or Coro) and most portable event loop.
.PP
For specific programs you can create additional event loops dynamically.
.PP
If you want to take advantage of kqueue (which often works properly for
sockets only) even though the default loop doesn't enable it, you can
\&\fIembed\fR a kqueue loop into the default loop: running the default loop
will then also service the kqueue loop to some extent. See the example in
the section about embed watchers for an example on how to achieve that.
.ie n .IP "$loop = new EV::Loop [$flags]" 4
.el .IP "\f(CW$loop\fR = new EV::Loop [$flags]" 4
.IX Item "$loop = new EV::Loop [$flags]"
Create a new event loop as per the specified flags. Please refer to
the \f(CW\*(C`ev_loop_new ()\*(C'\fR function description in the libev documentation
(<http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#GLOBAL_FUNCTIONS>,
or locally-installed as \fIEV::libev\fR manpage) for more info.
.Sp
The loop will automatically be destroyed when it is no longer referenced
by any watcher and the loop object goes out of scope.
.Sp
If you are not embedding the loop, then Using \f(CW\*(C`EV::FLAG_FORKCHECK\*(C'\fR
is recommended, as only the default event loop is protected by this
module. If you \fIare\fR embedding this loop in the default loop, this is not
necessary, as \f(CW\*(C`EV::embed\*(C'\fR automatically does the right thing on fork.
.ie n .IP "$loop\->loop_fork" 4
.el .IP "\f(CW$loop\fR\->loop_fork" 4
.IX Item "$loop->loop_fork"
Must be called after a fork in the child, before entering or continuing
the event loop. An alternative is to use \f(CW\*(C`EV::FLAG_FORKCHECK\*(C'\fR which calls
this function automatically, at some performance loss (refer to the libev
documentation).
.ie n .IP "$loop\->verify" 4
.el .IP "\f(CW$loop\fR\->verify" 4
.IX Item "$loop->verify"
Calls \f(CW\*(C`ev_verify\*(C'\fR to make internal consistency checks (for debugging
libev) and abort the program if any data structures were found to be
corrupted.
.ie n .IP "$loop = EV::default_loop [$flags]" 4
.el .IP "\f(CW$loop\fR = EV::default_loop [$flags]" 4
.IX Item "$loop = EV::default_loop [$flags]"
Return the default loop (which is a singleton object). Since this module
already creates the default loop with default flags, specifying flags here
will not have any effect unless you destroy the default loop first, which
isn't supported. So in short: don't do it, and if you break it, you get to
keep the pieces.
.SH "BASIC INTERFACE"
.IX Header "BASIC INTERFACE"
.ie n .IP "$EV::DIED" 4
.el .IP "\f(CW$EV::DIED\fR" 4
.IX Item "$EV::DIED"
Must contain a reference to a function that is called when a callback
throws an exception (with $@ containing the error). The default prints an
informative message and continues.
.Sp
If this callback throws an exception it will be silently ignored.
.ie n .IP "$flags = EV::supported_backends" 4
.el .IP "\f(CW$flags\fR = EV::supported_backends" 4
.IX Item "$flags = EV::supported_backends"
.PD 0
.ie n .IP "$flags = EV::recommended_backends" 4
.el .IP "\f(CW$flags\fR = EV::recommended_backends" 4
.IX Item "$flags = EV::recommended_backends"
.ie n .IP "$flags = EV::embeddable_backends" 4
.el .IP "\f(CW$flags\fR = EV::embeddable_backends" 4
.IX Item "$flags = EV::embeddable_backends"
.PD
Returns the set (see \f(CW\*(C`EV::BACKEND_*\*(C'\fR flags) of backends supported by this
instance of \s-1EV,\s0 the set of recommended backends (supposed to be good) for
this platform and the set of embeddable backends (see \s-1EMBED WATCHERS\s0).
.ie n .IP "EV::sleep $seconds" 4
.el .IP "EV::sleep \f(CW$seconds\fR" 4
.IX Item "EV::sleep $seconds"
Block the process for the given number of (fractional) seconds.
.ie n .IP "$time = EV::time" 4
.el .IP "\f(CW$time\fR = EV::time" 4
.IX Item "$time = EV::time"
Returns the current time in (fractional) seconds since the epoch.
.ie n .IP "$time = EV::now" 4
.el .IP "\f(CW$time\fR = EV::now" 4
.IX Item "$time = EV::now"
.PD 0
.ie n .IP "$time = $loop\->now" 4
.el .IP "\f(CW$time\fR = \f(CW$loop\fR\->now" 4
.IX Item "$time = $loop->now"
.PD
Returns the time the last event loop iteration has been started. This
is the time that (relative) timers are based on, and referring to it is
usually faster then calling EV::time.
.IP "EV::now_update" 4
.IX Item "EV::now_update"
.PD 0
.ie n .IP "$loop\->now_update" 4
.el .IP "\f(CW$loop\fR\->now_update" 4
.IX Item "$loop->now_update"
.PD
Establishes the current time by querying the kernel, updating the time
returned by \f(CW\*(C`EV::now\*(C'\fR in the progress. This is a costly operation and
is usually done automatically within \f(CW\*(C`EV::loop\*(C'\fR.
.Sp
This function is rarely useful, but when some event callback runs for a
very long time without entering the event loop, updating libev's idea of
the current time is a good idea.
.IP "EV::suspend" 4
.IX Item "EV::suspend"
.PD 0
.ie n .IP "$loop\->suspend" 4
.el .IP "\f(CW$loop\fR\->suspend" 4
.IX Item "$loop->suspend"
.IP "EV::resume" 4
.IX Item "EV::resume"
.ie n .IP "$loop\->resume" 4
.el .IP "\f(CW$loop\fR\->resume" 4
.IX Item "$loop->resume"
.PD
These two functions suspend and resume a loop, for use when the loop is
not used for a while and timeouts should not be processed.
.Sp
A typical use case would be an interactive program such as a game:  When
the user presses \f(CW\*(C`^Z\*(C'\fR to suspend the game and resumes it an hour later it
would be best to handle timeouts as if no time had actually passed while
the program was suspended. This can be achieved by calling \f(CW\*(C`suspend\*(C'\fR
in your \f(CW\*(C`SIGTSTP\*(C'\fR handler, sending yourself a \f(CW\*(C`SIGSTOP\*(C'\fR and calling
\&\f(CW\*(C`resume\*(C'\fR directly afterwards to resume timer processing.
.Sp
Effectively, all \f(CW\*(C`timer\*(C'\fR watchers will be delayed by the time spend
between \f(CW\*(C`suspend\*(C'\fR and \f(CW\*(C`resume\*(C'\fR, and all \f(CW\*(C`periodic\*(C'\fR watchers
will be rescheduled (that is, they will lose any events that would have
occured while suspended).
.Sp
After calling \f(CW\*(C`suspend\*(C'\fR you \fBmust not\fR call \fIany\fR function on the given
loop other than \f(CW\*(C`resume\*(C'\fR, and you \fBmust not\fR call \f(CW\*(C`resume\*(C'\fR
without a previous call to \f(CW\*(C`suspend\*(C'\fR.
.Sp
Calling \f(CW\*(C`suspend\*(C'\fR/\f(CW\*(C`resume\*(C'\fR has the side effect of updating the event
loop time (see \f(CW\*(C`now_update\*(C'\fR).
.ie n .IP "$backend = EV::backend" 4
.el .IP "\f(CW$backend\fR = EV::backend" 4
.IX Item "$backend = EV::backend"
.PD 0
.ie n .IP "$backend = $loop\->backend" 4
.el .IP "\f(CW$backend\fR = \f(CW$loop\fR\->backend" 4
.IX Item "$backend = $loop->backend"
.PD
Returns an integer describing the backend used by libev (\s-1EV::BACKEND_SELECT\s0
or \s-1EV::BACKEND_EPOLL\s0).
.ie n .IP "$active = EV::run [$flags]" 4
.el .IP "\f(CW$active\fR = EV::run [$flags]" 4
.IX Item "$active = EV::run [$flags]"
.PD 0
.ie n .IP "$active = $loop\->run ([$flags])" 4
.el .IP "\f(CW$active\fR = \f(CW$loop\fR\->run ([$flags])" 4
.IX Item "$active = $loop->run ([$flags])"
.PD
Begin checking for events and calling callbacks. It returns when a
callback calls EV::break or the flasg are nonzero (in which case the
return value is true) or when there are no active watchers which reference
the loop (keepalive is true), in which case the return value will be
false. The returnv alue can generally be interpreted as \*(L"if true, there is
more work left to do\*(R".
.Sp
The \f(CW$flags\fR argument can be one of the following:
.Sp
.Vb 3
\&   0               as above
\&   EV::RUN_ONCE    block at most once (wait, but do not loop)
\&   EV::RUN_NOWAIT  do not block at all (fetch/handle events but do not wait)
.Ve
.IP "EV::break [$how]" 4
.IX Item "EV::break [$how]"
.PD 0
.ie n .IP "$loop\->break ([$how])" 4
.el .IP "\f(CW$loop\fR\->break ([$how])" 4
.IX Item "$loop->break ([$how])"
.PD
When called with no arguments or an argument of \s-1EV::BREAK_ONE,\s0 makes the
innermost call to EV::loop return.
.Sp
When called with an argument of \s-1EV::BREAK_ALL,\s0 all calls to EV::loop will
return as fast as possible.
.Sp
When called with an argument of \s-1EV::BREAK_CANCEL,\s0 any pending break will
be cancelled.
.ie n .IP "$count = EV::iteration" 4
.el .IP "\f(CW$count\fR = EV::iteration" 4
.IX Item "$count = EV::iteration"
.PD 0
.ie n .IP "$count = $loop\->iteration" 4
.el .IP "\f(CW$count\fR = \f(CW$loop\fR\->iteration" 4
.IX Item "$count = $loop->iteration"
.PD
Return the number of times the event loop has polled for new
events. Sometimes useful as a generation counter.
.ie n .IP "EV::once $fh_or_undef, $events, $timeout, $cb\->($revents)" 4
.el .IP "EV::once \f(CW$fh_or_undef\fR, \f(CW$events\fR, \f(CW$timeout\fR, \f(CW$cb\fR\->($revents)" 4
.IX Item "EV::once $fh_or_undef, $events, $timeout, $cb->($revents)"
.PD 0
.ie n .IP "$loop\->once ($fh_or_undef, $events, $timeout, $cb\->($revents))" 4
.el .IP "\f(CW$loop\fR\->once ($fh_or_undef, \f(CW$events\fR, \f(CW$timeout\fR, \f(CW$cb\fR\->($revents))" 4
.IX Item "$loop->once ($fh_or_undef, $events, $timeout, $cb->($revents))"
.PD
This function rolls together an I/O and a timer watcher for a single
one-shot event without the need for managing a watcher object.
.Sp
If \f(CW$fh_or_undef\fR is a filehandle or file descriptor, then \f(CW$events\fR
must be a bitset containing either \f(CW\*(C`EV::READ\*(C'\fR, \f(CW\*(C`EV::WRITE\*(C'\fR or \f(CW\*(C`EV::READ
| EV::WRITE\*(C'\fR, indicating the type of I/O event you want to wait for. If
you do not want to wait for some I/O event, specify \f(CW\*(C`undef\*(C'\fR for
\&\f(CW$fh_or_undef\fR and \f(CW0\fR for \f(CW$events\fR).
.Sp
If timeout is \f(CW\*(C`undef\*(C'\fR or negative, then there will be no
timeout. Otherwise a EV::timer with this value will be started.
.Sp
When an error occurs or either the timeout or I/O watcher triggers, then
the callback will be called with the received event set (in general
you can expect it to be a combination of \f(CW\*(C`EV::ERROR\*(C'\fR, \f(CW\*(C`EV::READ\*(C'\fR,
\&\f(CW\*(C`EV::WRITE\*(C'\fR and \f(CW\*(C`EV::TIMER\*(C'\fR).
.Sp
EV::once doesn't return anything: the watchers stay active till either
of them triggers, then they will be stopped and freed, and the callback
invoked.
.ie n .IP "EV::feed_fd_event $fd, $revents" 4
.el .IP "EV::feed_fd_event \f(CW$fd\fR, \f(CW$revents\fR" 4
.IX Item "EV::feed_fd_event $fd, $revents"
.PD 0
.ie n .IP "$loop\->feed_fd_event ($fd, $revents)" 4
.el .IP "\f(CW$loop\fR\->feed_fd_event ($fd, \f(CW$revents\fR)" 4
.IX Item "$loop->feed_fd_event ($fd, $revents)"
.PD
Feed an event on a file descriptor into \s-1EV. EV\s0 will react to this call as
if the readyness notifications specified by \f(CW$revents\fR (a combination of
\&\f(CW\*(C`EV::READ\*(C'\fR and \f(CW\*(C`EV::WRITE\*(C'\fR) happened on the file descriptor \f(CW$fd\fR.
.ie n .IP "EV::feed_signal_event $signal" 4
.el .IP "EV::feed_signal_event \f(CW$signal\fR" 4
.IX Item "EV::feed_signal_event $signal"
Feed a signal event into the default loop. \s-1EV\s0 will react to this call as
if the signal specified by \f(CW$signal\fR had occured.
.ie n .IP "EV::feed_signal $signal" 4
.el .IP "EV::feed_signal \f(CW$signal\fR" 4
.IX Item "EV::feed_signal $signal"
Feed a signal event into \s-1EV\s0 \- unlike \f(CW\*(C`EV::feed_signal_event\*(C'\fR, this works
regardless of which loop has registered the signal, and is mainly useful
fro custom signal implementations.
.ie n .IP "EV::set_io_collect_interval $time" 4
.el .IP "EV::set_io_collect_interval \f(CW$time\fR" 4
.IX Item "EV::set_io_collect_interval $time"
.PD 0
.ie n .IP "$loop\->set_io_collect_interval ($time)" 4
.el .IP "\f(CW$loop\fR\->set_io_collect_interval ($time)" 4
.IX Item "$loop->set_io_collect_interval ($time)"
.ie n .IP "EV::set_timeout_collect_interval $time" 4
.el .IP "EV::set_timeout_collect_interval \f(CW$time\fR" 4
.IX Item "EV::set_timeout_collect_interval $time"
.ie n .IP "$loop\->set_timeout_collect_interval ($time)" 4
.el .IP "\f(CW$loop\fR\->set_timeout_collect_interval ($time)" 4
.IX Item "$loop->set_timeout_collect_interval ($time)"
.PD
These advanced functions set the minimum block interval when polling for I/O events and the minimum
wait interval for timer events. See the libev documentation at
<http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#FUNCTIONS_CONTROLLING_THE_EVENT_LOOP>
(locally installed as \fIEV::libev\fR) for a more detailed discussion.
.ie n .IP "$count = EV::pending_count" 4
.el .IP "\f(CW$count\fR = EV::pending_count" 4
.IX Item "$count = EV::pending_count"
.PD 0
.ie n .IP "$count = $loop\->pending_count" 4
.el .IP "\f(CW$count\fR = \f(CW$loop\fR\->pending_count" 4
.IX Item "$count = $loop->pending_count"
.PD
Returns the number of currently pending watchers.
.IP "EV::invoke_pending" 4
.IX Item "EV::invoke_pending"
.PD 0
.ie n .IP "$loop\->invoke_pending" 4
.el .IP "\f(CW$loop\fR\->invoke_pending" 4
.IX Item "$loop->invoke_pending"
.PD
Invoke all currently pending watchers.
.SH "WATCHER OBJECTS"
.IX Header "WATCHER OBJECTS"
A watcher is an object that gets created to record your interest in some
event. For instance, if you want to wait for \s-1STDIN\s0 to become readable, you
would create an EV::io watcher for that:
.PP
.Vb 4
\&   my $watcher = EV::io *STDIN, EV::READ, sub {
\&      my ($watcher, $revents) = @_;
\&      warn "yeah, STDIN should now be readable without blocking!\en"
\&   };
.Ve
.PP
All watchers can be active (waiting for events) or inactive (paused). Only
active watchers will have their callbacks invoked. All callbacks will be
called with at least two arguments: the watcher and a bitmask of received
events.
.PP
Each watcher type has its associated bit in revents, so you can use the
same callback for multiple watchers. The event mask is named after the
type, i.e. EV::child sets \s-1EV::CHILD,\s0 EV::prepare sets \s-1EV::PREPARE,\s0
EV::periodic sets \s-1EV::PERIODIC\s0 and so on, with the exception of I/O events
(which can set both \s-1EV::READ\s0 and \s-1EV::WRITE\s0 bits).
.PP
In the rare case where one wants to create a watcher but not start it at
the same time, each constructor has a variant with a trailing \f(CW\*(C`_ns\*(C'\fR in
its name, e.g. EV::io has a non-starting variant EV::io_ns and so on.
.PP
Please note that a watcher will automatically be stopped when the watcher
object is destroyed, so you \fIneed\fR to keep the watcher objects returned by
the constructors.
.PP
Also, all methods changing some aspect of a watcher (\->set, \->priority,
\&\->fh and so on) automatically stop and start it again if it is active,
which means pending events get lost.
.SS "\s-1COMMON WATCHER METHODS\s0"
.IX Subsection "COMMON WATCHER METHODS"
This section lists methods common to all watchers.
.ie n .IP "$w\->start" 4
.el .IP "\f(CW$w\fR\->start" 4
.IX Item "$w->start"
Starts a watcher if it isn't active already. Does nothing to an already
active watcher. By default, all watchers start out in the active state
(see the description of the \f(CW\*(C`_ns\*(C'\fR variants if you need stopped watchers).
.ie n .IP "$w\->stop" 4
.el .IP "\f(CW$w\fR\->stop" 4
.IX Item "$w->stop"
Stop a watcher if it is active. Also clear any pending events (events that
have been received but that didn't yet result in a callback invocation),
regardless of whether the watcher was active or not.
.ie n .IP "$bool = $w\->is_active" 4
.el .IP "\f(CW$bool\fR = \f(CW$w\fR\->is_active" 4
.IX Item "$bool = $w->is_active"
Returns true if the watcher is active, false otherwise.
.ie n .IP "$current_data = $w\->data" 4
.el .IP "\f(CW$current_data\fR = \f(CW$w\fR\->data" 4
.IX Item "$current_data = $w->data"
.PD 0
.ie n .IP "$old_data = $w\->data ($new_data)" 4
.el .IP "\f(CW$old_data\fR = \f(CW$w\fR\->data ($new_data)" 4
.IX Item "$old_data = $w->data ($new_data)"
.PD
Queries a freely usable data scalar on the watcher and optionally changes
it. This is a way to associate custom data with a watcher:
.Sp
.Vb 4
\&   my $w = EV::timer 60, 0, sub {
\&      warn $_[0]\->data;
\&   };
\&   $w\->data ("print me!");
.Ve
.ie n .IP "$current_cb = $w\->cb" 4
.el .IP "\f(CW$current_cb\fR = \f(CW$w\fR\->cb" 4
.IX Item "$current_cb = $w->cb"
.PD 0
.ie n .IP "$old_cb = $w\->cb ($new_cb)" 4
.el .IP "\f(CW$old_cb\fR = \f(CW$w\fR\->cb ($new_cb)" 4
.IX Item "$old_cb = $w->cb ($new_cb)"
.PD
Queries the callback on the watcher and optionally changes it. You can do
this at any time without the watcher restarting.
.ie n .IP "$current_priority = $w\->priority" 4
.el .IP "\f(CW$current_priority\fR = \f(CW$w\fR\->priority" 4
.IX Item "$current_priority = $w->priority"
.PD 0
.ie n .IP "$old_priority = $w\->priority ($new_priority)" 4
.el .IP "\f(CW$old_priority\fR = \f(CW$w\fR\->priority ($new_priority)" 4
.IX Item "$old_priority = $w->priority ($new_priority)"
.PD
Queries the priority on the watcher and optionally changes it. Pending
watchers with higher priority will be invoked first. The valid range of
priorities lies between \s-1EV::MAXPRI\s0 (default 2) and \s-1EV::MINPRI\s0 (default
\&\-2). If the priority is outside this range it will automatically be
normalised to the nearest valid priority.
.Sp
The default priority of any newly-created watcher is 0.
.Sp
Note that the priority semantics have not yet been fleshed out and are
subject to almost certain change.
.ie n .IP "$w\->invoke ($revents)" 4
.el .IP "\f(CW$w\fR\->invoke ($revents)" 4
.IX Item "$w->invoke ($revents)"
Call the callback *now* with the given event mask.
.ie n .IP "$w\->feed_event ($revents)" 4
.el .IP "\f(CW$w\fR\->feed_event ($revents)" 4
.IX Item "$w->feed_event ($revents)"
Feed some events on this watcher into \s-1EV. EV\s0 will react to this call as if
the watcher had received the given \f(CW$revents\fR mask.
.ie n .IP "$revents = $w\->clear_pending" 4
.el .IP "\f(CW$revents\fR = \f(CW$w\fR\->clear_pending" 4
.IX Item "$revents = $w->clear_pending"
If the watcher is pending, this function clears its pending status and
returns its \f(CW$revents\fR bitset (as if its callback was invoked). If the
watcher isn't pending it does nothing and returns \f(CW0\fR.
.ie n .IP "$previous_state = $w\->keepalive ($bool)" 4
.el .IP "\f(CW$previous_state\fR = \f(CW$w\fR\->keepalive ($bool)" 4
.IX Item "$previous_state = $w->keepalive ($bool)"
Normally, \f(CW\*(C`EV::loop\*(C'\fR will return when there are no active watchers
(which is a \*(L"deadlock\*(R" because no progress can be made anymore). This is
convenient because it allows you to start your watchers (and your jobs),
call \f(CW\*(C`EV::loop\*(C'\fR once and when it returns you know that all your jobs are
finished (or they forgot to register some watchers for their task :).
.Sp
Sometimes, however, this gets in your way, for example when the module
that calls \f(CW\*(C`EV::loop\*(C'\fR (usually the main program) is not the same module
as a long-living watcher (for example a \s-1DNS\s0 client module written by
somebody else even). Then you might want any outstanding requests to be
handled, but you would not want to keep \f(CW\*(C`EV::loop\*(C'\fR from returning just
because you happen to have this long-running \s-1UDP\s0 port watcher.
.Sp
In this case you can clear the keepalive status, which means that even
though your watcher is active, it won't keep \f(CW\*(C`EV::loop\*(C'\fR from returning.
.Sp
The initial value for keepalive is true (enabled), and you can change it
any time.
.Sp
Example: Register an I/O watcher for some \s-1UDP\s0 socket but do not keep the
event loop from running just because of that watcher.
.Sp
.Vb 3
\&   my $udp_socket = ...
\&   my $udp_watcher = EV::io $udp_socket, EV::READ, sub { ... };
\&   $udp_watcher\->keepalive (0);
.Ve
.ie n .IP "$loop = $w\->loop" 4
.el .IP "\f(CW$loop\fR = \f(CW$w\fR\->loop" 4
.IX Item "$loop = $w->loop"
Return the loop that this watcher is attached to.
.SH "WATCHER TYPES"
.IX Header "WATCHER TYPES"
Each of the following subsections describes a single watcher type.
.PP
\fII/O \s-1WATCHERS\s0 \- is this file descriptor readable or writable?\fR
.IX Subsection "I/O WATCHERS - is this file descriptor readable or writable?"
.ie n .IP "$w = EV::io $fileno_or_fh, $eventmask, $callback" 4
.el .IP "\f(CW$w\fR = EV::io \f(CW$fileno_or_fh\fR, \f(CW$eventmask\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::io $fileno_or_fh, $eventmask, $callback"
.PD 0
.ie n .IP "$w = EV::io_ns $fileno_or_fh, $eventmask, $callback" 4
.el .IP "\f(CW$w\fR = EV::io_ns \f(CW$fileno_or_fh\fR, \f(CW$eventmask\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::io_ns $fileno_or_fh, $eventmask, $callback"
.ie n .IP "$w = $loop\->io ($fileno_or_fh, $eventmask, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->io ($fileno_or_fh, \f(CW$eventmask\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->io ($fileno_or_fh, $eventmask, $callback)"
.ie n .IP "$w = $loop\->io_ns ($fileno_or_fh, $eventmask, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->io_ns ($fileno_or_fh, \f(CW$eventmask\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->io_ns ($fileno_or_fh, $eventmask, $callback)"
.PD
As long as the returned watcher object is alive, call the \f(CW$callback\fR
when at least one of events specified in \f(CW$eventmask\fR occurs.
.Sp
The \f(CW$eventmask\fR can be one or more of these constants ORed together:
.Sp
.Vb 2
\&  EV::READ     wait until read() wouldn\*(Aqt block anymore
\&  EV::WRITE    wait until write() wouldn\*(Aqt block anymore
.Ve
.Sp
The \f(CW\*(C`io_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.ie n .IP "$w\->set ($fileno_or_fh, $eventmask)" 4
.el .IP "\f(CW$w\fR\->set ($fileno_or_fh, \f(CW$eventmask\fR)" 4
.IX Item "$w->set ($fileno_or_fh, $eventmask)"
Reconfigures the watcher, see the constructor above for details. Can be
called at any time.
.ie n .IP "$current_fh = $w\->fh" 4
.el .IP "\f(CW$current_fh\fR = \f(CW$w\fR\->fh" 4
.IX Item "$current_fh = $w->fh"
.PD 0
.ie n .IP "$old_fh = $w\->fh ($new_fh)" 4
.el .IP "\f(CW$old_fh\fR = \f(CW$w\fR\->fh ($new_fh)" 4
.IX Item "$old_fh = $w->fh ($new_fh)"
.PD
Returns the previously set filehandle and optionally set a new one.
.ie n .IP "$current_eventmask = $w\->events" 4
.el .IP "\f(CW$current_eventmask\fR = \f(CW$w\fR\->events" 4
.IX Item "$current_eventmask = $w->events"
.PD 0
.ie n .IP "$old_eventmask = $w\->events ($new_eventmask)" 4
.el .IP "\f(CW$old_eventmask\fR = \f(CW$w\fR\->events ($new_eventmask)" 4
.IX Item "$old_eventmask = $w->events ($new_eventmask)"
.PD
Returns the previously set event mask and optionally set a new one.
.PP
\fI\s-1TIMER WATCHERS\s0 \- relative and optionally repeating timeouts\fR
.IX Subsection "TIMER WATCHERS - relative and optionally repeating timeouts"
.ie n .IP "$w = EV::timer $after, $repeat, $callback" 4
.el .IP "\f(CW$w\fR = EV::timer \f(CW$after\fR, \f(CW$repeat\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::timer $after, $repeat, $callback"
.PD 0
.ie n .IP "$w = EV::timer_ns $after, $repeat, $callback" 4
.el .IP "\f(CW$w\fR = EV::timer_ns \f(CW$after\fR, \f(CW$repeat\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::timer_ns $after, $repeat, $callback"
.ie n .IP "$w = $loop\->timer ($after, $repeat, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->timer ($after, \f(CW$repeat\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->timer ($after, $repeat, $callback)"
.ie n .IP "$w = $loop\->timer_ns ($after, $repeat, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->timer_ns ($after, \f(CW$repeat\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->timer_ns ($after, $repeat, $callback)"
.PD
Calls the callback after \f(CW$after\fR seconds (which may be fractional). If
\&\f(CW$repeat\fR is non-zero, the timer will be restarted (with the \f(CW$repeat\fR
value as \f(CW$after\fR) after the callback returns.
.Sp
This means that the callback would be called roughly after \f(CW$after\fR
seconds, and then every \f(CW$repeat\fR seconds. The timer does his best not
to drift, but it will not invoke the timer more often then once per event
loop iteration, and might drift in other cases. If that isn't acceptable,
look at EV::periodic, which can provide long-term stable timers.
.Sp
The timer is based on a monotonic clock, that is, if somebody is sitting
in front of the machine while the timer is running and changes the system
clock, the timer will nevertheless run (roughly) the same time.
.Sp
The \f(CW\*(C`timer_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.ie n .IP "$w\->set ($after, $repeat = 0)" 4
.el .IP "\f(CW$w\fR\->set ($after, \f(CW$repeat\fR = 0)" 4
.IX Item "$w->set ($after, $repeat = 0)"
Reconfigures the watcher, see the constructor above for details. Can be called at
any time.
.ie n .IP "$w\->again" 4
.el .IP "\f(CW$w\fR\->again" 4
.IX Item "$w->again"
.PD 0
.ie n .IP "$w\->again ($repeat)" 4
.el .IP "\f(CW$w\fR\->again ($repeat)" 4
.IX Item "$w->again ($repeat)"
.PD
Similar to the \f(CW\*(C`start\*(C'\fR method, but has special semantics for repeating timers:
.Sp
If the timer is active and non-repeating, it will be stopped.
.Sp
If the timer is active and repeating, reset the timeout to occur
\&\f(CW$repeat\fR seconds after now.
.Sp
If the timer is inactive and repeating, start it using the repeat value.
.Sp
Otherwise do nothing.
.Sp
This behaviour is useful when you have a timeout for some \s-1IO\s0
operation. You create a timer object with the same value for \f(CW$after\fR and
\&\f(CW$repeat\fR, and then, in the read/write watcher, run the \f(CW\*(C`again\*(C'\fR method
on the timeout.
.Sp
If called with a \f(CW$repeat\fR argument, then it uses this a timer repeat
value.
.ie n .IP "$after = $w\->remaining" 4
.el .IP "\f(CW$after\fR = \f(CW$w\fR\->remaining" 4
.IX Item "$after = $w->remaining"
Calculates and returns the remaining time till the timer will fire.
.PP
\fI\s-1PERIODIC WATCHERS\s0 \- to cron or not to cron?\fR
.IX Subsection "PERIODIC WATCHERS - to cron or not to cron?"
.ie n .IP "$w = EV::periodic $at, $interval, $reschedule_cb, $callback" 4
.el .IP "\f(CW$w\fR = EV::periodic \f(CW$at\fR, \f(CW$interval\fR, \f(CW$reschedule_cb\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::periodic $at, $interval, $reschedule_cb, $callback"
.PD 0
.ie n .IP "$w = EV::periodic_ns $at, $interval, $reschedule_cb, $callback" 4
.el .IP "\f(CW$w\fR = EV::periodic_ns \f(CW$at\fR, \f(CW$interval\fR, \f(CW$reschedule_cb\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::periodic_ns $at, $interval, $reschedule_cb, $callback"
.ie n .IP "$w = $loop\->periodic ($at, $interval, $reschedule_cb, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->periodic ($at, \f(CW$interval\fR, \f(CW$reschedule_cb\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->periodic ($at, $interval, $reschedule_cb, $callback)"
.ie n .IP "$w = $loop\->periodic_ns ($at, $interval, $reschedule_cb, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->periodic_ns ($at, \f(CW$interval\fR, \f(CW$reschedule_cb\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->periodic_ns ($at, $interval, $reschedule_cb, $callback)"
.PD
Similar to EV::timer, but is not based on relative timeouts but on
absolute times. Apart from creating \*(L"simple\*(R" timers that trigger \*(L"at\*(R" the
specified time, it can also be used for non-drifting absolute timers and
more complex, cron-like, setups that are not adversely affected by time
jumps (i.e. when the system clock is changed by explicit date \-s or other
means such as ntpd). It is also the most complex watcher type in \s-1EV.\s0
.Sp
It has three distinct \*(L"modes\*(R":
.RS 4
.IP "\(bu" 4
absolute timer ($interval = \f(CW$reschedule_cb\fR = 0)
.Sp
This time simply fires at the wallclock time \f(CW$at\fR and doesn't repeat. It
will not adjust when a time jump occurs, that is, if it is to be run
at January 1st 2011 then it will run when the system time reaches or
surpasses this time.
.IP "\(bu" 4
repeating interval timer ($interval > 0, \f(CW$reschedule_cb\fR = 0)
.Sp
In this mode the watcher will always be scheduled to time out at the
next \f(CW\*(C`$at + N * $interval\*(C'\fR time (for some integer N) and then repeat,
regardless of any time jumps.
.Sp
This can be used to create timers that do not drift with respect to system
time:
.Sp
.Vb 1
\&   my $hourly = EV::periodic 0, 3600, 0, sub { print "once/hour\en" };
.Ve
.Sp
That doesn't mean there will always be 3600 seconds in between triggers,
but only that the the callback will be called when the system time shows a
full hour (\s-1UTC\s0).
.Sp
Another way to think about it (for the mathematically inclined) is that
EV::periodic will try to run the callback in this mode at the next
possible time where \f(CW\*(C`$time = $at (mod $interval)\*(C'\fR, regardless of any time
jumps.
.IP "\(bu" 4
manual reschedule mode ($reschedule_cb = coderef)
.Sp
In this mode \f(CW$interval\fR and \f(CW$at\fR are both being ignored. Instead, each
time the periodic watcher gets scheduled, the reschedule callback
($reschedule_cb) will be called with the watcher as first, and the current
time as second argument.
.Sp
\&\fIThis callback \s-1MUST NOT\s0 stop or destroy this or any other periodic
watcher, ever, and \s-1MUST NOT\s0 call any event loop functions or methods\fR. If
you need to stop it, return 1e30 and stop it afterwards. You may create
and start a \f(CW\*(C`EV::prepare\*(C'\fR watcher for this task.
.Sp
It must return the next time to trigger, based on the passed time value
(that is, the lowest time value larger than or equal to to the second
argument). It will usually be called just before the callback will be
triggered, but might be called at other times, too.
.Sp
This can be used to create very complex timers, such as a timer that
triggers on each midnight, local time (actually 24 hours after the last
midnight, to keep the example simple. If you know a way to do it correctly
in about the same space (without requiring elaborate modules), drop me a
note :):
.Sp
.Vb 2
\&   my $daily = EV::periodic 0, 0, sub {
\&      my ($w, $now) = @_;
\&
\&      use Time::Local ();
\&      my (undef, undef, undef, $d, $m, $y) = localtime $now;
\&      86400 + Time::Local::timelocal 0, 0, 0, $d, $m, $y
\&   }, sub {
\&      print "it\*(Aqs midnight or likely shortly after, now\en";
\&   };
.Ve
.RE
.RS 4
.Sp
The \f(CW\*(C`periodic_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.RE
.ie n .IP "$w\->set ($at, $interval, $reschedule_cb)" 4
.el .IP "\f(CW$w\fR\->set ($at, \f(CW$interval\fR, \f(CW$reschedule_cb\fR)" 4
.IX Item "$w->set ($at, $interval, $reschedule_cb)"
Reconfigures the watcher, see the constructor above for details. Can be called at
any time.
.ie n .IP "$w\->again" 4
.el .IP "\f(CW$w\fR\->again" 4
.IX Item "$w->again"
Simply stops and starts the watcher again.
.ie n .IP "$time = $w\->at" 4
.el .IP "\f(CW$time\fR = \f(CW$w\fR\->at" 4
.IX Item "$time = $w->at"
Return the time that the watcher is expected to trigger next.
.PP
\fI\s-1SIGNAL WATCHERS\s0 \- signal me when a signal gets signalled!\fR
.IX Subsection "SIGNAL WATCHERS - signal me when a signal gets signalled!"
.ie n .IP "$w = EV::signal $signal, $callback" 4
.el .IP "\f(CW$w\fR = EV::signal \f(CW$signal\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::signal $signal, $callback"
.PD 0
.ie n .IP "$w = EV::signal_ns $signal, $callback" 4
.el .IP "\f(CW$w\fR = EV::signal_ns \f(CW$signal\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::signal_ns $signal, $callback"
.ie n .IP "$w = $loop\->signal ($signal, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->signal ($signal, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->signal ($signal, $callback)"
.ie n .IP "$w = $loop\->signal_ns ($signal, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->signal_ns ($signal, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->signal_ns ($signal, $callback)"
.PD
Call the callback when \f(CW$signal\fR is received (the signal can be specified by
number or by name, just as with \f(CW\*(C`kill\*(C'\fR or \f(CW%SIG\fR).
.Sp
Only one event loop can grab a given signal \- attempting to grab the same
signal from two \s-1EV\s0 loops will crash the program immediately or cause data
corruption.
.Sp
\&\s-1EV\s0 will grab the signal for the process (the kernel only allows one
component to receive a signal at a time) when you start a signal watcher,
and removes it again when you stop it. Perl does the same when you
add/remove callbacks to \f(CW%SIG\fR, so watch out.
.Sp
You can have as many signal watchers per signal as you want.
.Sp
The \f(CW\*(C`signal_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.ie n .IP "$w\->set ($signal)" 4
.el .IP "\f(CW$w\fR\->set ($signal)" 4
.IX Item "$w->set ($signal)"
Reconfigures the watcher, see the constructor above for details. Can be
called at any time.
.ie n .IP "$current_signum = $w\->signal" 4
.el .IP "\f(CW$current_signum\fR = \f(CW$w\fR\->signal" 4
.IX Item "$current_signum = $w->signal"
.PD 0
.ie n .IP "$old_signum = $w\->signal ($new_signal)" 4
.el .IP "\f(CW$old_signum\fR = \f(CW$w\fR\->signal ($new_signal)" 4
.IX Item "$old_signum = $w->signal ($new_signal)"
.PD
Returns the previously set signal (always as a number not name) and
optionally set a new one.
.PP
\fI\s-1CHILD WATCHERS\s0 \- watch out for process status changes\fR
.IX Subsection "CHILD WATCHERS - watch out for process status changes"
.ie n .IP "$w = EV::child $pid, $trace, $callback" 4
.el .IP "\f(CW$w\fR = EV::child \f(CW$pid\fR, \f(CW$trace\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::child $pid, $trace, $callback"
.PD 0
.ie n .IP "$w = EV::child_ns $pid, $trace, $callback" 4
.el .IP "\f(CW$w\fR = EV::child_ns \f(CW$pid\fR, \f(CW$trace\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::child_ns $pid, $trace, $callback"
.ie n .IP "$w = $loop\->child ($pid, $trace, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->child ($pid, \f(CW$trace\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->child ($pid, $trace, $callback)"
.ie n .IP "$w = $loop\->child_ns ($pid, $trace, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->child_ns ($pid, \f(CW$trace\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->child_ns ($pid, $trace, $callback)"
.PD
Call the callback when a status change for pid \f(CW$pid\fR (or any pid
if \f(CW$pid\fR is 0) has been received (a status change happens when the
process terminates or is killed, or, when trace is true, additionally when
it is stopped or continued). More precisely: when the process receives
a \f(CW\*(C`SIGCHLD\*(C'\fR, \s-1EV\s0 will fetch the outstanding exit/wait status for all
changed/zombie children and call the callback.
.Sp
It is valid (and fully supported) to install a child watcher after a child
has exited but before the event loop has started its next iteration (for
example, first you \f(CW\*(C`fork\*(C'\fR, then the new child process might exit, and
only then do you install a child watcher in the parent for the new pid).
.Sp
You can access both exit (or tracing) status and pid by using the
\&\f(CW\*(C`rstatus\*(C'\fR and \f(CW\*(C`rpid\*(C'\fR methods on the watcher object.
.Sp
You can have as many pid watchers per pid as you want, they will all be
called.
.Sp
The \f(CW\*(C`child_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.ie n .IP "$w\->set ($pid, $trace)" 4
.el .IP "\f(CW$w\fR\->set ($pid, \f(CW$trace\fR)" 4
.IX Item "$w->set ($pid, $trace)"
Reconfigures the watcher, see the constructor above for details. Can be called at
any time.
.ie n .IP "$current_pid = $w\->pid" 4
.el .IP "\f(CW$current_pid\fR = \f(CW$w\fR\->pid" 4
.IX Item "$current_pid = $w->pid"
Returns the previously set process id and optionally set a new one.
.ie n .IP "$exit_status = $w\->rstatus" 4
.el .IP "\f(CW$exit_status\fR = \f(CW$w\fR\->rstatus" 4
.IX Item "$exit_status = $w->rstatus"
Return the exit/wait status (as returned by waitpid, see the waitpid entry
in perlfunc).
.ie n .IP "$pid = $w\->rpid" 4
.el .IP "\f(CW$pid\fR = \f(CW$w\fR\->rpid" 4
.IX Item "$pid = $w->rpid"
Return the pid of the awaited child (useful when you have installed a
watcher for all pids).
.PP
\fI\s-1STAT WATCHERS\s0 \- did the file attributes just change?\fR
.IX Subsection "STAT WATCHERS - did the file attributes just change?"
.ie n .IP "$w = EV::stat $path, $interval, $callback" 4
.el .IP "\f(CW$w\fR = EV::stat \f(CW$path\fR, \f(CW$interval\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::stat $path, $interval, $callback"
.PD 0
.ie n .IP "$w = EV::stat_ns $path, $interval, $callback" 4
.el .IP "\f(CW$w\fR = EV::stat_ns \f(CW$path\fR, \f(CW$interval\fR, \f(CW$callback\fR" 4
.IX Item "$w = EV::stat_ns $path, $interval, $callback"
.ie n .IP "$w = $loop\->stat ($path, $interval, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->stat ($path, \f(CW$interval\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->stat ($path, $interval, $callback)"
.ie n .IP "$w = $loop\->stat_ns ($path, $interval, $callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->stat_ns ($path, \f(CW$interval\fR, \f(CW$callback\fR)" 4
.IX Item "$w = $loop->stat_ns ($path, $interval, $callback)"
.PD
Call the callback when a file status change has been detected on
\&\f(CW$path\fR. The \f(CW$path\fR does not need to exist, changing from \*(L"path exists\*(R"
to \*(L"path does not exist\*(R" is a status change like any other.
.Sp
The \f(CW$interval\fR is a recommended polling interval for systems where
OS-supported change notifications don't exist or are not supported. If
you use \f(CW0\fR then an unspecified default is used (which is highly
recommended!), which is to be expected to be around five seconds usually.
.Sp
This watcher type is not meant for massive numbers of stat watchers,
as even with OS-supported change notifications, this can be
resource-intensive.
.Sp
The \f(CW\*(C`stat_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.ie n .IP "... = $w\->stat" 4
.el .IP "... = \f(CW$w\fR\->stat" 4
.IX Item "... = $w->stat"
This call is very similar to the perl \f(CW\*(C`stat\*(C'\fR built-in: It stats (using
\&\f(CW\*(C`lstat\*(C'\fR) the path specified in the watcher and sets perls stat cache (as
well as \s-1EV\s0's idea of the current stat values) to the values found.
.Sp
In scalar context, a boolean is return indicating success or failure of
the stat. In list context, the same 13\-value list as with stat is returned
(except that the blksize and blocks fields are not reliable).
.Sp
In the case of an error, errno is set to \f(CW\*(C`ENOENT\*(C'\fR (regardless of the
actual error value) and the \f(CW\*(C`nlink\*(C'\fR value is forced to zero (if the stat
was successful then nlink is guaranteed to be non-zero).
.Sp
See also the next two entries for more info.
.ie n .IP "... = $w\->attr" 4
.el .IP "... = \f(CW$w\fR\->attr" 4
.IX Item "... = $w->attr"
Just like \f(CW\*(C`$w\->stat\*(C'\fR, but without the initial stat'ing: this returns
the values most recently detected by \s-1EV.\s0 See the next entry for more info.
.ie n .IP "... = $w\->prev" 4
.el .IP "... = \f(CW$w\fR\->prev" 4
.IX Item "... = $w->prev"
Just like \f(CW\*(C`$w\->stat\*(C'\fR, but without the initial stat'ing: this returns
the previous set of values, before the change.
.Sp
That is, when the watcher callback is invoked, \f(CW\*(C`$w\->prev\*(C'\fR will be set
to the values found \fIbefore\fR a change was detected, while \f(CW\*(C`$w\->attr\*(C'\fR
returns the values found leading to the change detection. The difference (if any)
between \f(CW\*(C`prev\*(C'\fR and \f(CW\*(C`attr\*(C'\fR is what triggered the callback.
.Sp
If you did something to the filesystem object and do not want to trigger
yet another change, you can call \f(CW\*(C`stat\*(C'\fR to update \s-1EV\s0's idea of what the
current attributes are.
.ie n .IP "$w\->set ($path, $interval)" 4
.el .IP "\f(CW$w\fR\->set ($path, \f(CW$interval\fR)" 4
.IX Item "$w->set ($path, $interval)"
Reconfigures the watcher, see the constructor above for details. Can be
called at any time.
.ie n .IP "$current_path = $w\->path" 4
.el .IP "\f(CW$current_path\fR = \f(CW$w\fR\->path" 4
.IX Item "$current_path = $w->path"
.PD 0
.ie n .IP "$old_path = $w\->path ($new_path)" 4
.el .IP "\f(CW$old_path\fR = \f(CW$w\fR\->path ($new_path)" 4
.IX Item "$old_path = $w->path ($new_path)"
.PD
Returns the previously set path and optionally set a new one.
.ie n .IP "$current_interval = $w\->interval" 4
.el .IP "\f(CW$current_interval\fR = \f(CW$w\fR\->interval" 4
.IX Item "$current_interval = $w->interval"
.PD 0
.ie n .IP "$old_interval = $w\->interval ($new_interval)" 4
.el .IP "\f(CW$old_interval\fR = \f(CW$w\fR\->interval ($new_interval)" 4
.IX Item "$old_interval = $w->interval ($new_interval)"
.PD
Returns the previously set interval and optionally set a new one. Can be
used to query the actual interval used.
.PP
\fI\s-1IDLE WATCHERS\s0 \- when you've got nothing better to do...\fR
.IX Subsection "IDLE WATCHERS - when you've got nothing better to do..."
.ie n .IP "$w = EV::idle $callback" 4
.el .IP "\f(CW$w\fR = EV::idle \f(CW$callback\fR" 4
.IX Item "$w = EV::idle $callback"
.PD 0
.ie n .IP "$w = EV::idle_ns $callback" 4
.el .IP "\f(CW$w\fR = EV::idle_ns \f(CW$callback\fR" 4
.IX Item "$w = EV::idle_ns $callback"
.ie n .IP "$w = $loop\->idle ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->idle ($callback)" 4
.IX Item "$w = $loop->idle ($callback)"
.ie n .IP "$w = $loop\->idle_ns ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->idle_ns ($callback)" 4
.IX Item "$w = $loop->idle_ns ($callback)"
.PD
Call the callback when there are no other pending watchers of the same or
higher priority (excluding check, prepare and other idle watchers of the
same or lower priority, of course). They are called idle watchers because
when the watcher is the highest priority pending event in the process, the
process is considered to be idle at that priority.
.Sp
If you want a watcher that is only ever called when \fIno\fR other events are
outstanding you have to set the priority to \f(CW\*(C`EV::MINPRI\*(C'\fR.
.Sp
The process will not block as long as any idle watchers are active, and
they will be called repeatedly until stopped.
.Sp
For example, if you have idle watchers at priority \f(CW0\fR and \f(CW1\fR, and
an I/O watcher at priority \f(CW0\fR, then the idle watcher at priority \f(CW1\fR
and the I/O watcher will always run when ready. Only when the idle watcher
at priority \f(CW1\fR is stopped and the I/O watcher at priority \f(CW0\fR is not
pending with the \f(CW0\fR\-priority idle watcher be invoked.
.Sp
The \f(CW\*(C`idle_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.PP
\fI\s-1PREPARE WATCHERS\s0 \- customise your event loop!\fR
.IX Subsection "PREPARE WATCHERS - customise your event loop!"
.ie n .IP "$w = EV::prepare $callback" 4
.el .IP "\f(CW$w\fR = EV::prepare \f(CW$callback\fR" 4
.IX Item "$w = EV::prepare $callback"
.PD 0
.ie n .IP "$w = EV::prepare_ns $callback" 4
.el .IP "\f(CW$w\fR = EV::prepare_ns \f(CW$callback\fR" 4
.IX Item "$w = EV::prepare_ns $callback"
.ie n .IP "$w = $loop\->prepare ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->prepare ($callback)" 4
.IX Item "$w = $loop->prepare ($callback)"
.ie n .IP "$w = $loop\->prepare_ns ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->prepare_ns ($callback)" 4
.IX Item "$w = $loop->prepare_ns ($callback)"
.PD
Call the callback just before the process would block. You can still
create/modify any watchers at this point.
.Sp
See the EV::check watcher, below, for explanations and an example.
.Sp
The \f(CW\*(C`prepare_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.PP
\fI\s-1CHECK WATCHERS\s0 \- customise your event loop even more!\fR
.IX Subsection "CHECK WATCHERS - customise your event loop even more!"
.ie n .IP "$w = EV::check $callback" 4
.el .IP "\f(CW$w\fR = EV::check \f(CW$callback\fR" 4
.IX Item "$w = EV::check $callback"
.PD 0
.ie n .IP "$w = EV::check_ns $callback" 4
.el .IP "\f(CW$w\fR = EV::check_ns \f(CW$callback\fR" 4
.IX Item "$w = EV::check_ns $callback"
.ie n .IP "$w = $loop\->check ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->check ($callback)" 4
.IX Item "$w = $loop->check ($callback)"
.ie n .IP "$w = $loop\->check_ns ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->check_ns ($callback)" 4
.IX Item "$w = $loop->check_ns ($callback)"
.PD
Call the callback just after the process wakes up again (after it has
gathered events), but before any other callbacks have been invoked.
.Sp
This can be used to integrate other event-based software into the \s-1EV\s0
mainloop: You register a prepare callback and in there, you create io and
timer watchers as required by the other software. Here is a real-world
example of integrating Net::SNMP (with some details left out):
.Sp
.Vb 1
\&   our @snmp_watcher;
\&
\&   our $snmp_prepare = EV::prepare sub {
\&      # do nothing unless active
\&      $dispatcher\->{_event_queue_h}
\&         or return;
\&
\&      # make the dispatcher handle any outstanding stuff
\&      ... not shown
\&
\&      # create an I/O watcher for each and every socket
\&      @snmp_watcher = (
\&         (map { EV::io $_, EV::READ, sub { } }
\&             keys %{ $dispatcher\->{_descriptors} }),
\&
\&         EV::timer +($event\->[Net::SNMP::Dispatcher::_ACTIVE]
\&                     ? $event\->[Net::SNMP::Dispatcher::_TIME] \- EV::now : 0),
\&                    0, sub { },
\&      );
\&   };
.Ve
.Sp
The callbacks are irrelevant (and are not even being called), the
only purpose of those watchers is to wake up the process as soon as
one of those events occurs (socket readable, or timer timed out). The
corresponding EV::check watcher will then clean up:
.Sp
.Vb 3
\&   our $snmp_check = EV::check sub {
\&      # destroy all watchers
\&      @snmp_watcher = ();
\&
\&      # make the dispatcher handle any new stuff
\&      ... not shown
\&   };
.Ve
.Sp
The callbacks of the created watchers will not be called as the watchers
are destroyed before this can happen (remember EV::check gets called
first).
.Sp
The \f(CW\*(C`check_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.IP "\s-1EV::CHECK\s0 constant issues" 4
.IX Item "EV::CHECK constant issues"
Like all other watcher types, there is a bitmask constant for use in
\&\f(CW$revents\fR and other places. The \f(CW\*(C`EV::CHECK\*(C'\fR is special as it has
the same name as the \f(CW\*(C`CHECK\*(C'\fR sub called by Perl. This doesn't cause
big issues on newer perls (beginning with 5.8.9), but it means thatthe
constant must be \fIinlined\fR, i.e. runtime calls will not work. That means
that as long as you always \f(CW\*(C`use EV\*(C'\fR and then \f(CW\*(C`EV::CHECK\*(C'\fR you are on the
safe side.
.PP
\fI\s-1FORK WATCHERS\s0 \- the audacity to resume the event loop after a fork\fR
.IX Subsection "FORK WATCHERS - the audacity to resume the event loop after a fork"
.PP
Fork watchers are called when a \f(CW\*(C`fork ()\*(C'\fR was detected. The invocation
is done before the event loop blocks next and before \f(CW\*(C`check\*(C'\fR watchers
are being called, and only in the child after the fork.
.ie n .IP "$w = EV::fork $callback" 4
.el .IP "\f(CW$w\fR = EV::fork \f(CW$callback\fR" 4
.IX Item "$w = EV::fork $callback"
.PD 0
.ie n .IP "$w = EV::fork_ns $callback" 4
.el .IP "\f(CW$w\fR = EV::fork_ns \f(CW$callback\fR" 4
.IX Item "$w = EV::fork_ns $callback"
.ie n .IP "$w = $loop\->fork ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->fork ($callback)" 4
.IX Item "$w = $loop->fork ($callback)"
.ie n .IP "$w = $loop\->fork_ns ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->fork_ns ($callback)" 4
.IX Item "$w = $loop->fork_ns ($callback)"
.PD
Call the callback before the event loop is resumed in the child process
after a fork.
.Sp
The \f(CW\*(C`fork_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.PP
\fI\s-1EMBED WATCHERS\s0 \- when one backend isn't enough...\fR
.IX Subsection "EMBED WATCHERS - when one backend isn't enough..."
.PP
This is a rather advanced watcher type that lets you embed one event loop
into another (currently only \s-1IO\s0 events are supported in the embedded
loop, other types of watchers might be handled in a delayed or incorrect
fashion and must not be used).
.PP
See the libev documentation at
<http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#code_ev_embed_code_when_one_backend_>
(locally installed as \fIEV::libev\fR) for more details.
.PP
In short, this watcher is most useful on \s-1BSD\s0 systems without working
kqueue to still be able to handle a large number of sockets:
.PP
.Vb 1
\&   my $socket_loop;
\&  
\&   # check wether we use SELECT or POLL _and_ KQUEUE is supported
\&   if (
\&     (EV::backend & (EV::BACKEND_POLL | EV::BACKEND_SELECT))
\&     && (EV::supported_backends & EV::embeddable_backends & EV::BACKEND_KQUEUE)
\&   ) {
\&     # use kqueue for sockets
\&     $socket_loop = new EV::Loop EV::BACKEND_KQUEUE | EV::FLAG_NOENV;
\&   }
\&  
\&   # use the default loop otherwise
\&   $socket_loop ||= EV::default_loop;
.Ve
.ie n .IP "$w = EV::embed $otherloop[, $callback]" 4
.el .IP "\f(CW$w\fR = EV::embed \f(CW$otherloop\fR[, \f(CW$callback\fR]" 4
.IX Item "$w = EV::embed $otherloop[, $callback]"
.PD 0
.ie n .IP "$w = EV::embed_ns $otherloop[, $callback]" 4
.el .IP "\f(CW$w\fR = EV::embed_ns \f(CW$otherloop\fR[, \f(CW$callback\fR]" 4
.IX Item "$w = EV::embed_ns $otherloop[, $callback]"
.ie n .IP "$w = $loop\->embed ($otherloop[, $callback])" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->embed ($otherloop[, \f(CW$callback\fR])" 4
.IX Item "$w = $loop->embed ($otherloop[, $callback])"
.ie n .IP "$w = $loop\->embed_ns ($otherloop[, $callback])" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->embed_ns ($otherloop[, \f(CW$callback\fR])" 4
.IX Item "$w = $loop->embed_ns ($otherloop[, $callback])"
.PD
Call the callback when the embedded event loop (\f(CW$otherloop\fR) has any
I/O activity. The \f(CW$callback\fR is optional: if it is missing, then the
embedded event loop will be managed automatically (which is recommended),
otherwise you have to invoke \f(CW\*(C`sweep\*(C'\fR yourself.
.Sp
The \f(CW\*(C`embed_ns\*(C'\fR variant doesn't start (activate) the newly created watcher.
.PP
\fI\s-1ASYNC WATCHERS\s0 \- how to wake up another event loop\fR
.IX Subsection "ASYNC WATCHERS - how to wake up another event loop"
.PP
Async watchers are provided by \s-1EV,\s0 but have little use in perl directly,
as perl neither supports threads running in parallel nor direct access to
signal handlers or other contexts where they could be of value.
.PP
It is, however, possible to use them from the \s-1XS\s0 level.
.PP
Please see the libev documentation for further details.
.ie n .IP "$w = EV::async $callback" 4
.el .IP "\f(CW$w\fR = EV::async \f(CW$callback\fR" 4
.IX Item "$w = EV::async $callback"
.PD 0
.ie n .IP "$w = EV::async_ns $callback" 4
.el .IP "\f(CW$w\fR = EV::async_ns \f(CW$callback\fR" 4
.IX Item "$w = EV::async_ns $callback"
.ie n .IP "$w = $loop\->async ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->async ($callback)" 4
.IX Item "$w = $loop->async ($callback)"
.ie n .IP "$w = $loop\->async_ns ($callback)" 4
.el .IP "\f(CW$w\fR = \f(CW$loop\fR\->async_ns ($callback)" 4
.IX Item "$w = $loop->async_ns ($callback)"
.ie n .IP "$w\->send" 4
.el .IP "\f(CW$w\fR\->send" 4
.IX Item "$w->send"
.ie n .IP "$bool = $w\->async_pending" 4
.el .IP "\f(CW$bool\fR = \f(CW$w\fR\->async_pending" 4
.IX Item "$bool = $w->async_pending"
.PD
.PP
\fI\s-1CLEANUP WATCHERS\s0 \- how to clean up when the event loop goes away\fR
.IX Subsection "CLEANUP WATCHERS - how to clean up when the event loop goes away"
.PP
Cleanup watchers are not supported on the Perl level, they can only be
used via \s-1XS\s0 currently.
.SH "PERL SIGNALS"
.IX Header "PERL SIGNALS"
While Perl signal handling (\f(CW%SIG\fR) is not affected by \s-1EV,\s0 the behaviour
with \s-1EV\s0 is as the same as any other C library: Perl-signals will only be
handled when Perl runs, which means your signal handler might be invoked
only the next time an event callback is invoked.
.PP
The solution is to use \s-1EV\s0 signal watchers (see \f(CW\*(C`EV::signal\*(C'\fR), which will
ensure proper operations with regards to other event watchers.
.PP
If you cannot do this for whatever reason, you can also force a watcher
to be called on every event loop iteration by installing a \f(CW\*(C`EV::check\*(C'\fR
watcher:
.PP
.Vb 1
\&   my $async_check = EV::check sub { };
.Ve
.PP
This ensures that perl gets into control for a short time to handle any
pending signals, and also ensures (slightly) slower overall operation.
.SH "ITHREADS"
.IX Header "ITHREADS"
Ithreads are not supported by this module in any way. Perl pseudo-threads
is evil stuff and must die. Real threads as provided by Coro are fully
supported (and enhanced support is available via Coro::EV).
.SH "FORK"
.IX Header "FORK"
Most of the \*(L"improved\*(R" event delivering mechanisms of modern operating
systems have quite a few problems with \fBfork\fR\|(2) (to put it bluntly: it is
not supported and usually destructive). Libev makes it possible to work
around this by having a function that recreates the kernel state after
fork in the child.
.PP
On non\-win32 platforms, this module requires the pthread_atfork
functionality to do this automatically for you. This function is quite
buggy on most BSDs, though, so \s-1YMMV.\s0 The overhead for this is quite
negligible, because everything the function currently does is set a flag
that is checked only when the event loop gets used the next time, so when
you do fork but not use \s-1EV,\s0 the overhead is minimal.
.PP
On win32, there is no notion of fork so all this doesn't apply, of course.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
EV::MakeMaker \- MakeMaker interface to \s-1XS API,\s0 \s-1EV::ADNS\s0
(asynchronous \s-1DNS\s0), Glib::EV (makes Glib/Gtk2 use \s-1EV\s0 as event
loop), EV::Glib (embed Glib into \s-1EV\s0), Coro::EV (efficient thread
integration), Net::SNMP::EV (asynchronous \s-1SNMP\s0), AnyEvent for
event-loop agnostic and portable event driven programming.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://home.schmorp.de/
.Ve

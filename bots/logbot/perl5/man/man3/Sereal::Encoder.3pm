.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Sereal::Encoder 3pm"
.TH Sereal::Encoder 3pm "2020-02-04" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sereal::Encoder \- Fast, compact, powerful binary serialization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Sereal::Encoder qw(encode_sereal sereal_encode_with_object);
\&
\&  my $encoder = Sereal::Encoder\->new({...options...});
\&  my $out = $encoder\->encode($structure);
\&
\&  # alternatively the functional interface:
\&  $out = sereal_encode_with_object($encoder, $structure);
\&
\&  # much slower functional interface with no persistent objects:
\&  $out = encode_sereal($structure, {... options ...});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library implements an efficient, compact-output, and feature-rich
serializer using a binary protocol called \fISereal\fR.
Its sister module Sereal::Decoder implements a decoder for this format.
The two are released separately to allow for independent and safer upgrading.
If you care greatly about performance, consider reading the Sereal::Performance
documentation after finishing this document.
.PP
The Sereal protocol version emitted by this encoder implementation is currently
protocol version 4 by default.
.PP
The protocol specification and many other bits of documentation
can be found in the github repository. Right now, the specification is at
<https://github.com/Sereal/Sereal/blob/master/sereal_spec.pod>,
there is a discussion of the design objectives in
<https://github.com/Sereal/Sereal/blob/master/README.pod>, and the output
of our benchmarks can be seen at
<https://github.com/Sereal/Sereal/wiki/Sereal\-Comparison\-Graphs>.
For more information on getting the best performance out of Sereal, have a look
at the \*(L"\s-1PERFORMANCE\*(R"\s0 section below.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "new"
.IX Subsection "new"
Constructor. Optionally takes a hash reference as first parameter. This hash
reference may contain any number of options that influence the behaviour of the
encoder.
.PP
Currently, the following options are recognized, none of them are on
by default.
.PP
\fIcompress\fR
.IX Subsection "compress"
.PP
If this option provided and true, compression of the document body is enabled.
As of Sereal version 4, three different compression techniques are supported
and can be enabled by setting \f(CW\*(C`compress\*(C'\fR to the respective named
constants (exportable from the \f(CW\*(C`Sereal::Encoder\*(C'\fR module):
Snappy (named constant: \f(CW\*(C`SRL_SNAPPY\*(C'\fR), Zlib (\f(CW\*(C`SRL_ZLIB\*(C'\fR) and Zstd (\f(CW\*(C`SRL_ZSTD\*(C'\fR).
For your convenience, there is also a \f(CW\*(C`SRL_UNCOMPRESSED\*(C'\fR
constant.
.PP
If this option is set, then the Snappy-related options below
are ignored. They are otherwise recognized for compatibility only.
.PP
\fIcompress_threshold\fR
.IX Subsection "compress_threshold"
.PP
The size threshold (in bytes) of the uncompressed output below which
compression is not even attempted even if enabled.
Defaults to one kilobyte (1024 bytes). Set this to 0 and \f(CW\*(C`compress\*(C'\fR to
a non\-\f(CW\*(C`SRL_UNCOMPRESSED\*(C'\fR value to always attempt to compress.
Note that the document will not be compressed if the resulting size
will be bigger than the original size (even if \f(CW\*(C`compress_threshold\*(C'\fR is 0).
.PP
\fIcompress_level\fR
.IX Subsection "compress_level"
.PP
If Zlib or Zstd compressions are used, then this option will set a compression
level: Zlib uses range from 1 (fastest) to 9 (best). Defaults to 6. Zstd uses
range from 1 (fastest) to 22 (best). Default is 3.
.PP
\fIsnappy\fR
.IX Subsection "snappy"
.PP
See also the \f(CW\*(C`compress\*(C'\fR option. This option is provided only for
compatibility with Sereal V1.
.PP
If set, the main payload of the Sereal document will be compressed using
Google's Snappy algorithm. This can yield anywhere from no effect
to significant savings on output size at rather low run time cost.
If in doubt, test with your data whether this helps or not.
.PP
The decoder (version 0.04 and up) will know how to handle Snappy-compressed
Sereal documents transparently.
.PP
\&\fBNote:\fR The \f(CW\*(C`snappy_incr\*(C'\fR and \f(CW\*(C`snappy\*(C'\fR options are identical in
Sereal protocol v2 and up (so by default). If using an older protocol version
(see \f(CW\*(C`protocol_version\*(C'\fR and \f(CW\*(C`use_protocol_v1\*(C'\fR options below)
to emit Sereal V1 documents, this emits non-incrementally decodable
documents. See \f(CW\*(C`snappy_incr\*(C'\fR in those cases.
.PP
\fIsnappy_incr\fR
.IX Subsection "snappy_incr"
.PP
See also the \f(CW\*(C`compress\*(C'\fR option. This option is provided only for
compatibility with Sereal V1.
.PP
Same as the \f(CW\*(C`snappy\*(C'\fR option for default operation (that is in Sereal v2 or up).
.PP
In Sereal V1, enables a version of the Snappy protocol which is suitable for
incremental parsing of packets. See also the \f(CW\*(C`snappy\*(C'\fR option above for
more details.
.PP
\fIsnappy_threshold\fR
.IX Subsection "snappy_threshold"
.PP
See also the \f(CW\*(C`compress\*(C'\fR option. This option is provided only for
compatibility with Sereal V1.
.PP
This option is a synonym for the \f(CW\*(C`compress_threshold\*(C'\fR option,
but only if Snappy compression is enabled.
.PP
\fIcroak_on_bless\fR
.IX Subsection "croak_on_bless"
.PP
If this option is set, then the encoder will refuse to serialize blessed
references and throw an exception instead.
.PP
This can be important because blessed references can mean executing
a destructor on a remote system or generally executing code based on
data.
.PP
See also \f(CW\*(C`no_bless_objects\*(C'\fR to skip the blessing of objects.
When both flags are set, \f(CW\*(C`croak_on_bless\*(C'\fR has a higher precedence then
\&\f(CW\*(C`no_bless_objects\*(C'\fR.
.PP
\fIfreeze_callbacks\fR
.IX Subsection "freeze_callbacks"
.PP
This option was introduced in Sereal v2 and needs a Sereal v2 decoder.
.PP
If this option is set, the encoder will check for and possibly invoke
the \f(CW\*(C`FREEZE\*(C'\fR method on any object in the input data. An object that
was serialized using its \f(CW\*(C`FREEZE\*(C'\fR method will have its corresponding
\&\f(CW\*(C`THAW\*(C'\fR class method called during deserialization. The exact semantics
are documented below under \*(L"\s-1FREEZE/THAW CALLBACK MECHANISM\*(R"\s0.
.PP
Beware that using this functionality means a significant slowdown for
object serialization. Even when serializing objects without a \f(CW\*(C`FREEZE\*(C'\fR
method, the additional method look up will cost a small amount of runtime.
Yes, \f(CW\*(C`Sereal::Encoder\*(C'\fR is so fast that this may make a difference.
.PP
\fIno_bless_objects\fR
.IX Subsection "no_bless_objects"
.PP
If this option is set, then the encoder will serialize blessed references
without the bless information and provide plain data structures instead.
.PP
See also the \f(CW\*(C`croak_on_bless\*(C'\fR option above for more details.
.PP
\fIundef_unknown\fR
.IX Subsection "undef_unknown"
.PP
If set, unknown/unsupported data structures will be encoded as \f(CW\*(C`undef\*(C'\fR
instead of throwing an exception.
.PP
Mutually exclusive with \f(CW\*(C`stringify_unknown\*(C'\fR.
See also \f(CW\*(C`warn_unknown\*(C'\fR below.
.PP
\fIstringify_unknown\fR
.IX Subsection "stringify_unknown"
.PP
If set, unknown/unsupported data structures will be stringified and
encoded as that string instead of throwing an exception. The
stringification may cause a warning to be emitted by perl.
.PP
Mutually exclusive with \f(CW\*(C`undef_unknown\*(C'\fR.
See also \f(CW\*(C`warn_unknown\*(C'\fR below.
.PP
\fIwarn_unknown\fR
.IX Subsection "warn_unknown"
.PP
Only has an effect if \f(CW\*(C`undef_unknown\*(C'\fR or \f(CW\*(C`stringify_unknown\*(C'\fR
are enabled.
.PP
If set to a positive integer,
any unknown/unsupported data structure encountered will emit a
warning. If set to a negative integer, it will warn for unsupported
data structures just the same as for a positive value with one
exception: For blessed, unsupported items that have string overloading,
we silently stringify without warning.
.PP
\fImax_recursion_depth\fR
.IX Subsection "max_recursion_depth"
.PP
\&\f(CW\*(C`Sereal::Encoder\*(C'\fR is recursive. If you pass it a Perl data structure
that is deeply nested, it will eventually exhaust the C stack. Therefore,
there is a limit on the depth of recursion that is accepted. It defaults
to 10000 nested calls. You may choose to override this value with the
\&\f(CW\*(C`max_recursion_depth\*(C'\fR option. Beware that setting it too high can
cause hard crashes, so only do that if you \fB\s-1KNOW\s0\fR that it is safe to
do so.
.PP
Do note that the setting is somewhat approximate. Setting it to 10000 may break at
somewhere between 9997 and 10003 nested structures depending on their types.
.PP
\fIcanonical\fR
.IX Subsection "canonical"
.PP
Enable all options which are related to producing canonical output, so that
two strucutures with similar contents produce the same serialized form.
.PP
See the caveats elsewhere in this document about producing canonical output.
.PP
Currently sets the default for the following parameters: \f(CW\*(C`canonical_refs\*(C'\fR
and \f(CW\*(C`sort_keys\*(C'\fR. If the option is explicitly set then this setting is ignored.
More options may be added in the future.
.PP
You are warned that use of this option may incur additional performance penalties
in a future release by enabling other options than those listed here.
.PP
\fIcanonical_refs\fR
.IX Subsection "canonical_refs"
.PP
Normally \f(CW\*(C`Sereal::Encoder\*(C'\fR will \s-1ARRAYREF\s0 and \s-1HASHREF\s0 tags when the item contains
less than 16 items, and and is not referenced more than once. This flag will
override this optimization and use a standard \s-1REFN ARRAY\s0 style tag output. This
is primarily useful for producing canonical output and for testing Sereal itself.
.PP
See \*(L"\s-1CANONICAL REPRESENTATION\*(R"\s0 for why you might want to use this, and
for the various caveats involved.
.PP
\fIsort_keys\fR
.IX Subsection "sort_keys"
.PP
Normally \f(CW\*(C`Sereal::Encoder\*(C'\fR will output hashes in whatever order is convenient,
generally that used by perl to actually store the hash, or whatever order
was returned by a tied hash.
.PP
If this option is enabled then the Encoder will sort the keys before outputting
them. It uses more memory, and is quite a bit slower than the default.
.PP
Generally speaking this should mean that a hash and a copy should produce the
same output. Nevertheless the user is warned that Perl has a way of \*(L"morphing\*(R"
variables on use, and some of its rules are a little arcane (for instance utf8
keys), and so two hashes that might appear to be the same might still produce
different output as far as Sereal is concerned.
.PP
As of 3.006_007 (prerelease candidate for 3.007) the sort order has been changed
to the following: order by length of keys (in bytes) ascending, then by byte
order of the raw underlying string, then by utf8ness, with non\-utf8 first. This
order was chosen because it is the most efficient to implement, both in terms
of memory and time. This sort order is enabled when sort_keys is set to 1.
.PP
You may also produce output in Perl \*(L"cmp\*(R" order, by setting sort_keys to 2.
And for backwards compatibility you may also produce output in reverse Perl
\&\*(L"cmp\*(R" order by setting sort_keys to 3. Prior to 3.006_007 this was the
only sort order possible, although it was not explicitly defined what it was.
.PP
Note that comparatively speaking both of the \*(L"cmp\*(R" sort orders are slow and
memory inefficient. Unless you have a really good reason stick to the default
which is fast and as lean as possible.
.PP
Unless you are concerned with \*(L"cross process canonical representation\*(R" then
it doesn't matter what option you choose.
.PP
See \*(L"\s-1CANONICAL REPRESENTATION\*(R"\s0 for why you might want to use this, and
for the various caveats involved.
.PP
\fIno_shared_hashkeys\fR
.IX Subsection "no_shared_hashkeys"
.PP
When the \f(CW\*(C`no_shared_hashkeys\*(C'\fR option is set to a true value, then
the encoder will disable the detection and elimination of repeated hash
keys. This only has an effect for serializing structures containing hashes.
By skipping the detection of repeated hash keys, performance goes up a bit,
but the size of the output can potentially be much larger.
.PP
Do not disable this unless you have a reason to.
.PP
\fIdedupe_strings\fR
.IX Subsection "dedupe_strings"
.PP
If this is option is enabled/true then Sereal will use a hash to encode duplicates
of strings during serialization efficiently using (internal) backreferences. This
has a performance and memory penalty during encoding so it defaults to off.
On the other hand, data structures with many duplicated strings will see a
significant reduction in the size of the encoded form. Currently only strings
longer than 3 characters will be deduped, however this may change in the future.
.PP
Note that Sereal will perform certain types of deduping automatically even
without this option. In particular class names and hash keys (see also the
\&\f(CW\*(C`no_shared_hashkeys\*(C'\fR setting) are deduped
regardless of this option. Only enable this if you have good reason to
believe that there are many duplicated strings as values in your data
structure.
.PP
Use of this option does not require an upgraded decoder (this option was added in
Sereal::Encoder 0.32). The deduping
is performed in such a way that older decoders should handle it just fine.
In other words, the output of a Sereal \fBdecoder\fR should not depend on
whether this option was used during \fBencoding\fR. See also below:
\&\fIaliased_dedupe_strings\fR.
.PP
\fIaliased_dedupe_strings\fR
.IX Subsection "aliased_dedupe_strings"
.PP
This is an advanced option that should be used only after fully understanding
its ramifications.
.PP
This option enables a mode of operation that is similar to \fIdedupe_strings\fR
and if both options are set, \fIaliased_dedupe_strings\fR takes precedence.
.PP
The behaviour of \fIaliased_dedupe_strings\fR differs from \fIdedupe_strings\fR
in that the duplicate occurrences of strings are emitted as Perl language
level \fBaliases\fR instead of as Sereal-internal backreferences. This means
that using this option actually produces a different output data structure
when decoding. The upshot is that with this option, the application
using (decoding) the data may save a lot of memory in some situations
but at the cost of potential action at a distance due to the aliasing.
.PP
\&\fIBeware:\fR The test suite currently does not cover this option as well as it
probably should. Patches welcome.
.PP
\fIprotocol_version\fR
.IX Subsection "protocol_version"
.PP
Specifies the version of the Sereal protocol to emit. Valid are integers
between 1 and the current version. If not specified, the most recent protocol
version will be used. See also \f(CW\*(C`use_protocol_v1\*(C'\fR:
.PP
It is strongly advised to use the latest protocol version outside of
migration periods.
.PP
\fIuse_protocol_v1\fR
.IX Subsection "use_protocol_v1"
.PP
This option is deprecated in favour of the \f(CW\*(C`protocol_version\*(C'\fR option (see
above).
.PP
If set, the encoder will emit Sereal documents following protocol version 1.
This is strongly discouraged except for temporary
compatibility/migration purposes.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "encode"
.IX Subsection "encode"
Given a Perl data structure, serializes that data structure and returns a
binary string that can be turned back into the original data structure by
Sereal::Decoder. The method expects a data structure to serialize as first
argument, optionally followed by a header data structure.
.PP
A header is intended for embedding small amounts of meta data, such as routing
information, in a document that allows users to avoid deserializing main body
needlessly.
.SS "encode_to_file"
.IX Subsection "encode_to_file"
.Vb 2
\&    Sereal::Encoder\->encode_to_file($file,$data,$append);
\&    $encoder\->encode_to_file($file,$data,$append);
.Ve
.PP
Encode the data specified and write it the named file.
If \f(CW$append\fR is true then the written data is appended to any
existing data, otherwise any existing data will be overwritten.
Dies if any errors occur during writing the encoded data.
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
.SS "sereal_encode_with_object"
.IX Subsection "sereal_encode_with_object"
The functional interface that is equivalent to using \f(CW\*(C`encode\*(C'\fR. Takes an
encoder object reference as first argument, followed by a data structure
and optional header to serialize.
.PP
This functional interface is marginally faster than the \s-1OO\s0 interface
since it avoids method resolution overhead and, on sufficiently modern
Perl versions, can usually avoid subroutine call overhead.
.SS "encode_sereal"
.IX Subsection "encode_sereal"
The functional interface that is equivalent to using \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`encode\*(C'\fR.
Expects a data structure to serialize as first argument, optionally followed
by a hash reference of options (see documentation for \f(CW\*(C`new()\*(C'\fR).
.PP
This function cannot be used for encoding a data structure with a header.
See \f(CW\*(C`encode_sereal_with_header_data\*(C'\fR.
.PP
This functional interface is significantly slower than the \s-1OO\s0 interface since
it cannot reuse the encoder object.
.SS "encode_sereal_with_header_data"
.IX Subsection "encode_sereal_with_header_data"
The functional interface that is equivalent to using \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`encode\*(C'\fR.
Expects a data structure and a header to serialize as first and second arguments,
optionally followed by a hash reference of options (see documentation for \f(CW\*(C`new()\*(C'\fR).
.PP
This functional interface is significantly slower than the \s-1OO\s0 interface since
it cannot reuse the encoder object.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
See Sereal::Performance for detailed considerations on performance
tuning. Let it just be said that:
.PP
\&\fBIf you care about performance at all, then use \*(L"sereal_encode_with_object\*(R" or the
\&\s-1OO\s0 interface instead of \*(L"encode_sereal\*(R". It's a significant difference
in performance if you are serializing small data structures.\fR
.PP
The exact performance in time and space depends heavily on the data structure
to be serialized. Often there is a trade-off between space and time. If in doubt,
do your own testing and most importantly \s-1ALWAYS TEST WITH REAL DATA.\s0 If you
care purely about speed at the expense of output size, you can use the
\&\f(CW\*(C`no_shared_hashkeys\*(C'\fR option for a small speed-up. If you need smaller output at
the cost of higher \s-1CPU\s0 load and more memory used during encoding/decoding,
try the \f(CW\*(C`dedupe_strings\*(C'\fR option and enable Snappy compression.
.PP
For ready-made comparison scripts, see the
\&\fIauthor_tools/bench.pl\fR and \fIauthor_tools/dbench.pl\fR programs that are part
of this distribution. Suffice to say that this library is easily competitive
in both time and space efficiency with the best alternatives.
.SH "FREEZE/THAW CALLBACK MECHANISM"
.IX Header "FREEZE/THAW CALLBACK MECHANISM"
This mechanism is enabled using the \f(CW\*(C`freeze_callbacks\*(C'\fR option of the encoder.
It is inspired by the equivalent mechanism in \s-1CBOR::XS\s0 and differs only
in one minor detail, explained below. The general mechanism is documented
in the \fIA \s-1GENERIC OBJECT SERIALIATION PROTOCOL\s0\fR section of Types::Serializer.
Similar to \s-1CBOR\s0 using \f(CW\*(C`CBOR\*(C'\fR, Sereal uses the string \f(CW\*(C`Sereal\*(C'\fR as a serializer
identifier for the callbacks.
.PP
The one difference to the mechanism as supported by \s-1CBOR\s0 is that in Sereal,
the \f(CW\*(C`FREEZE\*(C'\fR callback must return a single value. That value can be any
data structure supported by Sereal (hopefully without causing infinite recursion
by including the original object). But \f(CW\*(C`FREEZE\*(C'\fR can't return a list as with \s-1CBOR.\s0
This should not be any practical limitation whatsoever. Just return an array
reference instead of a list.
.PP
Here is a contrived example of a class implementing the \f(CW\*(C`FREEZE\*(C'\fR / \f(CW\*(C`THAW\*(C'\fR mechanism.
.PP
.Vb 2
\&  package
\&    File;
\&
\&  use Moo;
\&
\&  has \*(Aqpath\*(Aq => (is => \*(Aqro\*(Aq);
\&  has \*(Aqfh\*(Aq => (is => \*(Aqrw\*(Aq);
\&
\&  # open file handle if necessary and return it
\&  sub get_fh {
\&    my $self = shift;
\&    # This could also be done with fancier Moo(se) syntax
\&    my $fh = $self\->fh;
\&    if (not $fh) {
\&      open $fh, "<", $self\->path or die $!;
\&      $self\->fh($fh);
\&    }
\&    return $fh;
\&  }
\&
\&  sub FREEZE {
\&    my ($self, $serializer) = @_;
\&    # Could switch on $serializer here: JSON, CBOR, Sereal, ...
\&    # But this case is so simple that it will work with ALL of them.
\&    # Do not try to serialize our file handle! Path will be enough
\&    # to recreate.
\&    return $self\->path;
\&  }
\&
\&  sub THAW {
\&    my ($class, $serializer, $data) = @_;
\&    # Turn back into object.
\&    return $class\->new(path => $data);
\&  }
.Ve
.PP
Why is the \f(CW\*(C`FREEZE\*(C'\fR/\f(CW\*(C`THAW\*(C'\fR mechanism important here? Our contrived \f(CW\*(C`File\*(C'\fR
class may contain a file handle which can't be serialized. So \f(CW\*(C`FREEZE\*(C'\fR not
only returns just the path (which is more compact than encoding the actual
object contents), but it strips the file handle which can be lazily reopened
on the other side of the serialization/deserialization pipe.
But this example also shows that a naive implementation can easily end up
with subtle bugs. A file handle itself has state (position in file, etc).
Thus the deserialization in the above example won't accurately reproduce
the original state. It can't, of course, if it's deserialized in a different
environment anyway.
.SH "THREAD-SAFETY"
.IX Header "THREAD-SAFETY"
\&\f(CW\*(C`Sereal::Encoder\*(C'\fR is thread-safe on Perl's 5.8.7 and higher. This means
\&\*(L"thread-safe\*(R" in the sense that if you create a new thread, all
\&\f(CW\*(C`Sereal::Encoder\*(C'\fR objects will become a reference to undef in the new
thread. This might change in a future release to become a full clone
of the encoder object.
.SH "CANONICAL REPRESENTATION"
.IX Header "CANONICAL REPRESENTATION"
You might want to compare two data structures by comparing their serialized
byte strings.  For that to work reliably the serialization must take extra
steps to ensure that identical data structures are encoded into identical
serialized byte strings (a so-called \*(L"canonical representation\*(R").
.PP
Unfortunately in Perl there is no such thing as a \*(L"canonical representation\*(R".
Most people are interested in \*(L"structural equivalence\*(R" but even that is less
well defined than most people think. For instance in the following example:
.PP
.Vb 5
\&    my $array1= [ 0, 0 ];
\&    my $array2= do {
\&        my $zero= 0;
\&        sub{ \e@_ }\->($zero,$zero);
\&    };
.Ve
.PP
the question of whether \f(CW$array1\fR is structurally equivalent to \f(CW$array2\fR
is a subjective one. Sereal for instance would \fB\s-1NOT\s0\fR consider them
equivalent but \f(CW\*(C`Test::Deep\*(C'\fR would.  There are many examples of this in
Perl. Simply stringifying a number technically changes the scalar. Storable
would notice this, but Sereal generally would not.
.PP
Despite this as of 3.002 the Sereal encoder supports a \*(L"canonical\*(R" option
which will make a \*(L"best effort\*(R" attempt at producing a canonical
representation of a data structure.  This mode is actually a combination of
several other modes which may also be enabled independently, and as and when
we add new options to the encoder that would assist in this regard then
the \f(CW\*(C`canonical\*(C'\fR will also enable them. These options may come with a
performance penalty so care should be taken to read the Changes file and
test the performance implications when upgrading a system that uses this
option.
.PP
It is important to note that using canonical representation to determine
if two data structures are different is subject to false-positives. If
two Sereal encodings are identical you can generally assume that the
two data structures are functionally equivalent from the point of view of
normal Perl code (\s-1XS\s0 code might disagree). However if two Sereal
encodings differ the data structures may actually be functionally
equivalent.  In practice it seems the the false-positive rate is low,
but your milage may vary.
.PP
Some of the issues with producing a true canonical representation are
outlined below:
.IP "Sereal doesn't order the hash keys by default." 4
.IX Item "Sereal doesn't order the hash keys by default."
This can be enabled via the \f(CW\*(C`sort_keys\*(C'\fR, which is itself enabled by
\&\f(CW\*(C`canonical\*(C'\fR option.
.IP "Sereal output is sensitive to refcounts" 4
.IX Item "Sereal output is sensitive to refcounts"
This can be somewhat mitigated by the use of \f(CW\*(C`canonical_refs\*(C'\fR, see above.
.IP "There are multiple valid Sereal documents that you can produce for the same Perl data structure." 4
.IX Item "There are multiple valid Sereal documents that you can produce for the same Perl data structure."
Just sorting hash keys is not enough.  Some of the reasons
are outlined below. These issues are especially relevant when considering
language interoperability.
.RS 4
.IP "\s-1PAD\s0 bytes" 4
.IX Item "PAD bytes"
A trivial example is \s-1PAD\s0 bytes which
mean nothing and are skipped. They mostly exist for encoder optimizations to
prevent certain nasty backtracking situations from becoming O(n) at the cost of
one byte of output. An explicit canonical mode would have to outlaw them (or
add more of them) and thus require a much more complicated implementation of
refcount/weakref handing in the encoder while at the same time causing some
operations to go from O(1) to a full memcpy of everything after the point of
where we backtracked to. Nasty.
.IP "\s-1COPY\s0 tag" 4
.IX Item "COPY tag"
Another example is \s-1COPY.\s0 The \s-1COPY\s0 tag indicates that the next element is an
identical copy of a previous element (which is itself forbidden from including
\&\s-1COPY\s0's other than for class names). \s-1COPY\s0 is purely internal. The Perl/XS
implementation uses it to share hash keys and class names. One could use it for
other strings (theoretically), but doesn't for time-efficiency reasons. We'd
have to outlaw the use of this (significant) optimization of canonicalization.
.IP "\s-1REF\s0 representation" 4
.IX Item "REF representation"
Sereal represents a reference to an array as a sequence of
tags which, in its simplest form, reads \fI\s-1REF, ARRAY\s0 \f(CI$array_length\fI \s-1TAG1 TAG2 ...\s0\fR.
The separation of \*(L"\s-1REF\*(R"\s0 and \*(L"\s-1ARRAY\*(R"\s0 is necessary to properly implement all of
Perl's referencing and aliasing semantics correctly. Quite frequently, however,
your array is only referenced once and plainly so. If it's also at most 15 elements
long, Sereal optimizes all of the \*(L"\s-1REF\*(R"\s0 and \*(L"\s-1ARRAY\*(R"\s0 tags, as well as the length
into a special one byte \s-1ARRAYREF\s0 tag. This is a very significant optimization
for common cases. This, however, does mean that most arrays up to 15 elements
could be represented in two different, yet perfectly valid forms. \s-1ARRAYREF\s0 would
have to be outlawed for a properly canonical form. The exact same logic
applies to \s-1HASH\s0 vs. \s-1HASHREF.\s0 This behavior can be overridden by the
\&\f(CW\*(C`canonical_refs\*(C'\fR option, which disables use of \s-1HASHREF\s0 and \s-1ARRAYREF.\s0
.IP "Numeric representation" 4
.IX Item "Numeric representation"
Similar to how Sereal can represent arrays and hashes in a full and a compact
form. For small integers (between \-16 and +15 inclusive), Sereal emits only
one byte including the encoding of the type of data. For larger integers,
it can use either variants (positive only) or zigzag encoding, which can also
represent negative numbers. For a canonical mode, the space optimizations
would have to be turned off and it would have to be explicitly specified
whether variant or zigzag encoding is to be used for encoding positive
integers.
.Sp
Perl may choose to retain multiple representations of a scalar. Specifically,
it can convert integers, floating point numbers, and strings on the fly and
will aggressively cache the results. Normally, it remembers which of the
representations can be considered canonical, that means, which can be used
to recreate the others reliably. For example, \f(CW0\fR and \f(CW"0"\fR
can both be considered canonical since they naturally transform into each
other. Beyond intrinsic ambiguity, there are ways to
trick Perl into allowing a single scalar to have distinct string, integer,
and floating point representations that are all flagged as canonical, but can't
be transformed into each other. These are the so-called dualvars. Sereal
cannot represent dualvars (and that's a good thing).
.Sp
Floating point values can appear to be the same but serialize to different byte
strings due to insignificant 'noise' in the floating point representation. Sereal
supports different floating point precisions and will generally choose the most
compact that can represent your floating point number correctly.
.RE
.RS 4
.Sp
There's also a few cases where Sereal will produce different documents
for values that you might think are the same thing, because if you
e.g. compared them with \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`==\*(C'\fR in perl itself would think they
were equivalent. However for the purposes of serialization they're not
the same value.
.Sp
A good example of these cases is where Test::Deep and Sereal's
canonical mode differ. We have tests for some of these cases in
\&\fIt/030_canonical_vs_test_deep.t\fR. Here's the issues we've noticed so
far:
.IP "Sereal considers \s-1ASCII\s0 strings with the \s-1UTF\-8\s0 flag to be different from the same string without the \s-1UTF\-8\s0 flag" 4
.IX Item "Sereal considers ASCII strings with the UTF-8 flag to be different from the same string without the UTF-8 flag"
Consider:
.Sp
.Vb 1
\&    my $language_code = "en";
.Ve
.Sp
v.s.:
.Sp
.Vb 2
\&    my $language_code = "en";
\&    utf8::upgrade($en);
.Ve
.Sp
Sereal's canonical mode will encode these strings differently, as it
should, since the \s-1UTF\-8\s0 flag will be passed along on interpolation.
.Sp
But this can be confusing if you're just getting some user-supplied
\&\s-1ASCII\s0 strings that you may inadvertently toggle the \s-1UTF\-8\s0 flag on,
e.g. because you're comparing an \s-1ASCII\s0 value in a database to a value
submitted in a \s-1UTF\-8\s0 web form.
.IP "Sereal will encode strings that look like numbers as strings, unless they've been used in numeric context" 4
.IX Item "Sereal will encode strings that look like numbers as strings, unless they've been used in numeric context"
I.e. these values will be encoded differently, respectively:
.Sp
.Vb 4
\&    my $IV_x = "12345";
\&    my $IV_y = "12345" + 0;
\&    my $NV_x = "12.345";
\&    my $NV_y = "12.345" + 0;
.Ve
.Sp
But as noted above something like Test::Deep will consider these to be
the same thing.
.RE
.RS 4
.Sp
We might produce certain aggressive flags to the canonical mode in the
future to deal with this. For the cases noted above some combination
of turning the \s-1UTF\-8\s0 flag on on all strings, or stripping it from
strings that have it but are ASCII-only would \*(L"work\*(R", similarly we
could scan strings to see if they match \f(CW\*(C`looks_like_number()\*(C'\fR and if
so numify them.
.Sp
This would produce output that either would be a lot bigger (having to
encode all numbers as strings), or would be more expensive to generate
(having to scan strings for numeric or non-ASCII context), and for
some cases like the \s-1UTF\-8\s0 flag munging wouldn't be suitable for
general use outside of canonicialization.
.RE
.PP
Often, people don't actually care about \*(L"canonical\*(R" in the strict sense
required for real \fIidentity\fR checking. They just require a best-effort sort of
thing for caching. But it's a slippery slope!
.PP
In a nutshell, the \f(CW\*(C`canonical\*(C'\fR option may be sufficient for an application
which is simply serializing a cache key, and thus there's little harm in an
occasional false-negative, but think carefully before applying Sereal in other
use-cases.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
.IP "Strings Or Numbers" 4
.IX Item "Strings Or Numbers"
Perl does not make a strong distinction between strings and numbers, and from
an internal point of view it can be difficult to tell what the \*(L"right\*(R"
representation is for a given variable.
.Sp
Sereal tries to not be lossy. So if it detects that the string value of a var,
and the numeric value are different it will generally round trip the *string*
value. This means that \*(L"special\*(R" strings often used in Perl function returns,
like \*(L"0 but true\*(R", and \*(L"0e0\*(R", will round trip in a way that their normal Perl
semantics are preserved. However this also means that \*(L"non canonical\*(R" values,
like \*(L" 100 \*(R", which will numify as 100 without warnings, will round trip as
their string values.
.Sp
Perl also has some operators, the binary operators, ^, | and &, which do different
things depending on whether their arguments had been used in numeric context as
the following examples show:
.Sp
.Vb 2
\&    perl \-le\*(Aqmy $x="1"; $i=int($x); print unpack "H*", $x ^ "1"\*(Aq
\&    30
\&
\&    perl \-le\*(Aqmy $x="1"; print unpack "H*", $x ^ "1"\*(Aq
\&    00
\&
\&    perl \-le\*(Aqmy $x=" 1 "; $i=int($x); print unpack "H*", $x ^ "1"\*(Aq
\&    30
\&
\&    perl \-le\*(Aqmy $x=" 1 "; print unpack "H*", $x ^ "1"\*(Aq
\&    113120
.Ve
.Sp
Sereal currently cannot round trip this property properly.
.Sp
An extreme case of this problem is that of \*(L"dualvars\*(R", which can be created using
the \fBScalar::Util::dualvar()\fR function. This function allows one to create variables
which have string and integer values which are completely unrelated to each other.
Sereal currently will choose the *string* value when it detects these items.
.Sp
It is possible that a future release of the protocol will fix these issues.
.SH "BUGS, CONTACT AND SUPPORT"
.IX Header "BUGS, CONTACT AND SUPPORT"
For reporting bugs, please use the github bug tracker at
<http://github.com/Sereal/Sereal/issues>.
.PP
For support and discussion of Sereal, there are two Google Groups:
.PP
Announcements around Sereal (extremely low volume):
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-announce>
.PP
Sereal development list:
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-dev>
.SH "AUTHORS AND CONTRIBUTORS"
.IX Header "AUTHORS AND CONTRIBUTORS"
Yves Orton <demerphq@gmail.com>
.PP
Damian Gryski
.PP
Steffen Mueller <smueller@cpan.org>
.PP
Rafaël Garcia-Suarez
.PP
Ævar Arnfjörð Bjarmason <avar@cpan.org>
.PP
Tim Bunce
.PP
Daniel Dragan <bulkdd@cpan.org> (Windows support and bugfixes)
.PP
Zefram
.PP
Borislav Nikolov
.PP
Ivan Kruglov <ivan.kruglov@yahoo.com>
.PP
Some inspiration and code was taken from Marc Lehmann's
excellent \s-1JSON::XS\s0 module due to obvious overlap in
problem domain. Thank you!
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
This module was originally developed for Booking.com.
With approval from Booking.com, this module was generalized
and published on \s-1CPAN,\s0 for which the authors would like to express
their gratitude.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2012, 2013, 2014 by Steffen Mueller
Copyright (C) 2012, 2013, 2014 by Yves Orton
.PP
The license for the code in this distribution is the following,
with the exceptions listed below:
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Except portions taken from Marc Lehmann's code for the \s-1JSON::XS\s0
module, which is licensed under the same terms as this module.
.PP
Also except the code for Snappy compression library, whose license
is reproduced below and which, to the best of our knowledge,
is compatible with this module's license. The license for the
enclosed Snappy code is:
.PP
.Vb 2
\&  Copyright 2011, Google Inc.
\&  All rights reserved.
\&
\&  Redistribution and use in source and binary forms, with or without
\&  modification, are permitted provided that the following conditions are
\&  met:
\&
\&    * Redistributions of source code must retain the above copyright
\&  notice, this list of conditions and the following disclaimer.
\&    * Redistributions in binary form must reproduce the above
\&  copyright notice, this list of conditions and the following disclaimer
\&  in the documentation and/or other materials provided with the
\&  distribution.
\&    * Neither the name of Google Inc. nor the names of its
\&  contributors may be used to endorse or promote products derived from
\&  this software without specific prior written permission.
\&
\&  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\&  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
\&  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
\&  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
\&  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
\&  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
\&  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
\&  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
\&  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
\&  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
\&  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve

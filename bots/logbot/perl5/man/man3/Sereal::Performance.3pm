.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Sereal::Performance 3pm"
.TH Sereal::Performance 3pm "2020-02-02" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sereal::Performance \- Getting the most out of the Perl\-Sereal implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  # This is different from the standard module synopsis in
\&  # that it chooses performance over ease\-of\-use.
\&  # Think twice before micro\-optimizing your Sereal usage.
\&  # Usually, Sereal is a lot faster than most of one\*(Aqs code,
\&  # so unless you are doing bulk encoding/decoding, you are
\&  # better off optimizing for maintainability.
\&
\&  use Sereal qw(sereal_encode_with_object
\&                sereal_decode_with_object);
\&  my $enc = Sereal::Encoder\->new();
\&  my $dec = Sereal::Decoder\->new();
\&
\&  my $big_data_structure = {...};
\&
\&  my $srldoc = sereal_encode_with_object($enc, $big_data_structure);
\&
\&  my $and_back = sereal_decode_with_object($dec, $srldoc);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Using Sereal in the way that is optimally performant for your use
case can make quite a significant difference in performance. Broadly
speaking, there are two classes of tweaks you can do: choosing
the right options during encoding (sometimes incurring
trade-offs in output size) and calling the Sereal encode/decode
functions in the most efficient way.
.PP
If you are not yet using re-usable
Sereal::Encoder and Sereal::Decoder objects, then
read no further. By switching from the \f(CW\*(C`encode_sereal\*(C'\fR and
\&\f(CW\*(C`decode_sereal\*(C'\fR functions to either the \s-1OO\s0 interface or the
advanced functional interface, you will get a noticeable
speed boost as encoder and decoder structures can be reused.
This is particularly significant for the encoder, which can
re-use its output buffer. In some cases, such a warmed-up
encoder can avoid most memory allocations.
.PP
\&\fBI repeat, if you care about performance, then do not use
the \f(CB\*(C`encode_sereal\*(C'\fB and \f(CB\*(C`decode_sereal\*(C'\fB interface.\fR
.PP
The exact performance in time and space depends heavily on the data structure
to be (de\-)serialized. Often there is a trade-off between space and time. If in doubt,
do your own testing and most importantly \fB\s-1ALWAYS TEST WITH REAL DATA\s0\fR. If you
care purely about speed at the expense of output size, you can use the
\&\f(CW\*(C`no_shared_hashkeys\*(C'\fR option for a small speed-up, see below.
If you need smaller output at the cost of higher \s-1CPU\s0 load and more memory
used during encoding/decoding, try the \f(CW\*(C`dedupe_strings\*(C'\fR option and
enable Snappy compression.
.PP
For ready-made comparison scripts, see the
\&\fIauthor_tools/bench.pl\fR and \fIauthor_tools/dbench.pl\fR programs that are part
of this distribution. Suffice to say that this library is easily competitive
in both time and space efficiency with the best alternatives.
.PP
If switching to the \s-1OO\s0 interface is not enough, you may consider
switching to the advanced functional interface that avoids
method lookup overhead, and by inlining as custom Perl OPs,
may also avoid some of the Perl function call overhead (Perl
5.14 and up). This additional speed-up is only a constant-offset,
avoiding said method/function call, rather than speeding up encoding
itself and so will be most significant if you are working with
very small data sets.
.PP
\&\f(CW\*(C`sereal_encode_with_object\*(C'\fR and \f(CW\*(C`sereal_decode_with_object\*(C'\fR
are optionally exported from the Sereal module (or
\&\f(CW\*(C`Sereal::Encoder\*(C'\fR and \f(CW\*(C`Sereal::Decoder\*(C'\fR respectively).
They work the same as the object-oriented interface except
that they are invoked differently:
.PP
.Vb 1
\&  $srl_doc = $encoder\->encode($data);
.Ve
.PP
becomes
.PP
.Vb 1
\&  $srl_doc = sereal_encode_with_object($encoder, $data);
.Ve
.PP
and
.PP
.Vb 1
\&  $data = $decoder\->decode($srl_doc);
.Ve
.PP
becomes
.PP
.Vb 1
\&  $data = sereal_decode_with_object($decoder, $srl_doc);
.Ve
.PP
On Perl versions before 5.14, this will be marginally faster than
the \s-1OO\s0 interface as it avoids method lookup. This should rarely matter.
On Perl versions starting from 5.14, the function call to
\&\f(CW\*(C`sereal_encode_with_object\*(C'\fR or \f(CW\*(C`sereal_decode_with_object\*(C'\fR will
also be replaced with a custom Perl \s-1OP,\s0 thus avoiding most of the
function call overhead as well.
.ie n .SS "Tuning the ""Sereal::Encoder"""
.el .SS "Tuning the \f(CWSereal::Encoder\fP"
.IX Subsection "Tuning the Sereal::Encoder"
Several of the \f(CW\*(C`Sereal::Encoder\*(C'\fR options add or remove useful
behaviour and some of them come at a runtime performance cost.
.ie n .IP """no_shared_hashkeys""" 2
.el .IP "\f(CWno_shared_hashkeys\fR" 2
.IX Item "no_shared_hashkeys"
By default, Sereal will emit a \*(L"repetition\*(R" marker for hash keys
that were already previously encountered. Depending on your data
structure, this can save quite a bit of space in the generated
document. Consider, for example, encoding an array of many objects
of the same class. But it may not save anything if you don't have
a lot of repeated hash keys or don't even encode any hashes to
begin with.
.Sp
In those cases, you can turn this feature off with the \f(CW\*(C`no_shared_hashkeys\*(C'\fR
option for a small but measurable speed-up.
.ie n .IP """dedupe_strings""" 2
.el .IP "\f(CWdedupe_strings\fR" 2
.IX Item "dedupe_strings"
If set, this option will apply the de-duplication logic to all
strings that is only applied to hash keys by default. This
can be quite expensive in both memory and performance.
The same is true for \f(CW\*(C`aliased_dedupe_strings\*(C'\fR.
.ie n .IP """snappy"" and ""snappy_incr""" 2
.el .IP "\f(CWsnappy\fR and \f(CWsnappy_incr\fR" 2
.IX Item "snappy and snappy_incr"
Enabling Snappy compression can (but doesn't have to) make your
Sereal documents significantly smaller. How effective this
compression is for you depends entirely on the nature of your data.
Snappy compression is designed to be very fast. The additional
space savings are very often worth the small overhead.
.ie n .IP """freeze_callbacks""" 2
.el .IP "\f(CWfreeze_callbacks\fR" 2
.IX Item "freeze_callbacks"
Using custom Perl \f(CW\*(C`FREEZE\*(C'\fR callbacks is very expensive. If enabled,
the encoder has to do a method lookup at least once per class of an
object being serialized. If a \f(CW\*(C`FREEZE\*(C'\fR hook actually exists, calling
it will be even more expensive. If you care about ultimate performance,
use with care.
.ie n .IP """sort_keys""" 2
.el .IP "\f(CWsort_keys\fR" 2
.IX Item "sort_keys"
This option forces the encoder to always \f(CW\*(C`sort\*(C'\fR the entries in a hash
by its keys before writing them to the Sereal document. This can be
somewhat expensive for large hashes.
.SS "General Considerations"
.IX Subsection "General Considerations"
Perl variables (scalars specifically) can, at the same time,
hold multiple representations of the same data. If you create
and integer and use it as a string, it will be cached in its
string form. Sereal attempts to detect the most compact of
these representations for encoding, but can not always
succeed. For example, if a data structure was previously
also traversed by certain other serialization modules
(such as Storable), then the scalars in the structure
may have been irrevocably upgraded to a more complex
(and bigger) type. This is only an issue in crude benchmarks.
So if you plan to benchmark serialization, take care not
to re-use the test data structure between serializers for
results that do not depend on the order of operations.
.SH "BUGS, CONTACT AND SUPPORT"
.IX Header "BUGS, CONTACT AND SUPPORT"
For reporting bugs, please use the github bug tracker at
<http://github.com/Sereal/Sereal/issues>.
.PP
For support and discussion of Sereal, there are two Google Groups:
.PP
Announcements around Sereal (extremely low volume):
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-announce>
.PP
Sereal development list:
<https://groups.google.com/forum/?fromgroups#!forum/sereal\-dev>
.SH "AUTHORS AND CONTRIBUTORS"
.IX Header "AUTHORS AND CONTRIBUTORS"
Yves Orton <demerphq@gmail.com>
.PP
Damian Gryski
.PP
Steffen Mueller <smueller@cpan.org>
.PP
Rafaël Garcia-Suarez
.PP
Ævar Arnfjörð Bjarmason <avar@cpan.org>
.PP
Tim Bunce
.PP
Daniel Dragan <bulkdd@cpan.org> (Windows support and bugfixes)
.PP
Zefram
.PP
Some inspiration and code was taken from Marc Lehmann's
excellent \s-1JSON::XS\s0 module due to obvious overlap in
problem domain.
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
This module was originally developed for Booking.com.
With approval from Booking.com, this module was generalized
and published on \s-1CPAN,\s0 for which the authors would like to express
their gratitude.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2012, 2013, 2014 by Steffen Mueller
Copyright (C) 2012, 2013, 2014 by Yves Orton
.PP
The license for the code in this distribution is the following,
with the exceptions listed below:
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Except portions taken from Marc Lehmann's code for the \s-1JSON::XS\s0
module, which is licensed under the same terms as this module.
(Many thanks to Marc for inspiration, and code.)
.PP
Also except the code for Snappy compression library, whose license
is reproduced below and which, to the best of our knowledge,
is compatible with this module's license. The license for the
enclosed Snappy code is:
.PP
.Vb 2
\&  Copyright 2011, Google Inc.
\&  All rights reserved.
\&
\&  Redistribution and use in source and binary forms, with or without
\&  modification, are permitted provided that the following conditions are
\&  met:
\&
\&    * Redistributions of source code must retain the above copyright
\&  notice, this list of conditions and the following disclaimer.
\&    * Redistributions in binary form must reproduce the above
\&  copyright notice, this list of conditions and the following disclaimer
\&  in the documentation and/or other materials provided with the
\&  distribution.
\&    * Neither the name of Google Inc. nor the names of its
\&  contributors may be used to endorse or promote products derived from
\&  this software without specific prior written permission.
\&
\&  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\&  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
\&  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
\&  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
\&  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
\&  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
\&  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
\&  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
\&  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
\&  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
\&  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.Ve
